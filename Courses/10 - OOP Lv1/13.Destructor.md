<a id="arabic"></a>
[English ↙](#english)

<div dir="rtl" style="text-align: right">

# Destructors

## مراجعة الدرس السابق

في الدروس السابقة تعلمنا:
- **Constructor:** ميثود بتم مناداتها عند إنشاء object من الكلاس
- **Constructor Overloading:** يمكن عمل أكثر من constructor بـ parameters مختلفة
- يُستخدم الـ Constructor لعمل **initialization** للكلاس أو أي شيء نريده

## ما هو الـ Destructor؟

**Destructor** هو عكس الـ Constructor تماماً:
- **Constructor** جاء من كلمة بناء
- **Destructor** جاء من كلمة تدمير (Destruction)

## Memory Management والـ Objects

تماماً مثل الـ Variables العادية:
- عندما تكون في function وتنشئ `integer x`
- بعد انتهاء الـ function، يتم تدمير كل الـ variables
- هذا لتوفير الـ memory وتجنب الـ load

نفس الشيء مع الـ Objects:
- عندما ينتهي الـ scope الخاص بالـ object
- يتم تدميره من الـ memory
- **آخر method يتم استدعاؤها قبل التدمير هي الـ Destructor**

## مثال أساسي
</div>
<div dir="ltr">

```cpp
#include <iostream>
#include <string>
using namespace std;

class clsPerson
{
private:
    string _fullName;

public:
    // Constructor
    clsPerson()
    {
        _fullName = "Mohammed Abu Hadhoud";
        cout << "Hi, I am constructor" << endl;
    }

    // Destructor - لاحظ علامة التلدة (~)
    ~clsPerson()
    {
        cout << "Hi, I am destructor" << endl;
    }
};

int main()
{
    clsPerson person1;  // Constructor يُستدعى هنا
    
    // هنا البرنامج ينتهي، Destructor يُستدعى تلقائياً
    return 0;
}
```
</div>

<div dir="rtl" style="text-align: right">

**النتيجة:** 
- سترى فقط "Hi, I am constructor"
- لن ترى "Hi, I am destructor" لأن البرنامج ينتهي فوراً

## مثال أوضح: استخدام Functions
</div>
<div dir="ltr">

```cpp
#include <iostream>
#include <string>
using namespace std;

class clsPerson
{
private:
    string _fullName;

public:
    // Constructor
    clsPerson()
    {
        _fullName = "Mohammed Abu Hadhoud";
        cout << "Hi, I am constructor" << endl;
    }

    // Destructor
    ~clsPerson()
    {
        cout << "Hi, I am destructor" << endl;
    }
};

void function1()
{
    clsPerson person1;  // Object ينشأ هنا
    // Function تنتهي هنا، Object يُدمر
}

int main()
{
    function1();  // استدعاء الـ function
    
    return 0;
}
```
</div>

<div dir="rtl" style="text-align: right">

**النتيجة:**
```
Hi, I am constructor
Hi, I am destructor
```

**التفسير:**
1. عند استدعاء `function1()`: Constructor يُنادى
2. عند انتهاء `function1()`: Object يُدمر، Destructor يُنادى

## قواعد كتابة Destructor

### 1. الاسم
- نفس اسم الكلاس مع علامة **التلدة (~)** في البداية
- مثال: إذا كان اسم الكلاس `clsPerson`، الـ Destructor يكون `~clsPerson()`

### 2. القيود
- **لا يمكن عمل Overloading** للـ Destructor
- **لا يأخذ parameters**
- **لا يُرجع قيم**
- **destructor واحد فقط** لكل كلاس

### 3. الاستدعاء
- يُستدعى **تلقائياً** قبل تدمير الـ object
- **آخر method** يتم تنفيذها في الـ object

## مشكلة مع الـ Pointers
</div>
<div dir="ltr">

```cpp
#include <iostream>
#include <string>
using namespace std;

class clsPerson
{
public:
    clsPerson()
    {
        cout << "Hi, I am constructor" << endl;
    }

    ~clsPerson()
    {
        cout << "Hi, I am destructor" << endl;
    }
};

void function1()
{
    clsPerson person1;  // Object عادي
}

void function2()
{
    clsPerson* person2 = new clsPerson();  // Object بـ pointer
    // لا يوجد delete - هذا خطأ!
}

int main()
{
    function1();
    function2();
    
    return 0;
}
```
</div>

<div dir="rtl" style="text-align: right">

**النتيجة:**
```
Hi, I am constructor
Hi, I am destructor
Hi, I am constructor
```

**المشكلة:** 
- `function1`: Object عادي → Destructor يُستدعى
- `function2`: Object بـ pointer → **Destructor لا يُستدعى!**

## الحل: استخدام delete
</div>
<div dir="ltr">

```cpp
void function2()
{
    clsPerson* person2 = new clsPerson();  // Object بـ pointer
    
    // أي كود تريده...
    
    delete person2;  // تدمير Object يدوياً
}
```
</div>

<div dir="rtl" style="text-align: right">

**النتيجة الصحيحة:**
```
Hi, I am constructor
Hi, I am destructor
Hi, I am constructor
Hi, I am destructor
```

## القاعدة الذهبية في C++

> **كل `new` يجب أن يتبعها `delete`**

هذا لتجنب:
- **Memory Leaks** (تسرب الذاكرة)
- بطء البرنامج
- استنزاف الـ memory

## استخدامات الـ Destructor

يمكن استخدام الـ Destructor لـ:

### 1. حفظ البيانات
```cpp
~clsPerson()
{
    // حفظ البيانات في ملف أو قاعدة بيانات
    saveToFile();
}
```

### 2. إغلاق الاتصالات
```cpp
~clsPerson()
{
    // إغلاق اتصال قاعدة البيانات
    closeDatabaseConnection();
}
```

### 3. تحرير Resources
```cpp
~clsPerson()
{
    // تحرير objects أخرى
    delete relatedObject1;
    delete relatedObject2;
    delete relatedObject3;
}
```

</div>

<div dir="rtl" style="text-align: right">

## الخلاصة

**Destructor** هو:
- **آخر method** يُستدعى قبل تدمير الـ object
- يُستخدم لتنظيف الموارد وحفظ البيانات
- يُستدعى **تلقائياً** للـ objects العادية
- يحتاج **delete يدوي** للـ objects المُنشأة بـ pointers

**القواعد المهمة:**
- destructor واحد فقط لكل كلاس
- لا يأخذ parameters ولا يُرجع قيم
- كل `new` يجب أن يتبعها `delete`

**النصيحة:** استخدم الـ Destructor لتنظيف كل شيء قبل مغادرة الـ object - "ادخل نظيف واخرج نظيف"

</div>

<br><br><br><br><br><br><br><br><br>

<a id="english"></a>
[العربية ↗](#arabic)

# Destructors

## Review of Previous Lesson

In previous lessons we learned:
- **Constructor:** Method called when creating an object from a class
- **Constructor Overloading:** Can create multiple constructors with different parameters
- Constructor is used for **initialization** of the class or anything we need

## What is a Destructor?

**Destructor** is the exact opposite of Constructor:
- **Constructor** comes from the word building
- **Destructor** comes from the word destruction

## Memory Management and Objects

Just like regular Variables:
- When you're in a function and create `integer x`
- After the function ends, all variables are destroyed
- This is to save memory and avoid load

Same thing with Objects:
- When the scope of the object ends
- It gets destroyed from memory
- **The last method called before destruction is the Destructor**

## Basic Example

```cpp
#include <iostream>
#include <string>
using namespace std;

class clsPerson
{
private:
    string _fullName;

public:
    // Constructor
    clsPerson()
    {
        _fullName = "Mohammed Abu Hadhoud";
        cout << "Hi, I am constructor" << endl;
    }

    // Destructor - Note the tilde (~)
    ~clsPerson()
    {
        cout << "Hi, I am destructor" << endl;
    }
};

int main()
{
    clsPerson person1;  // Constructor is called here
    
    // Program ends here, Destructor is called automatically
    return 0;
}
```

**Result:** 
- You'll only see "Hi, I am constructor"
- You won't see "Hi, I am destructor" because the program ends immediately

## Clearer Example: Using Functions

```cpp
#include <iostream>
#include <string>
using namespace std;

class clsPerson
{
private:
    string _fullName;

public:
    // Constructor
    clsPerson()
    {
        _fullName = "Mohammed Abu Hadhoud";
        cout << "Hi, I am constructor" << endl;
    }

    // Destructor
    ~clsPerson()
    {
        cout << "Hi, I am destructor" << endl;
    }
};

void function1()
{
    clsPerson person1;  // Object is created here
    // Function ends here, Object is destroyed
}

int main()
{
    function1();  // Call the function
    
    return 0;
}
```

**Result:**
```
Hi, I am constructor
Hi, I am destructor
```

**Explanation:**
1. When calling `function1()`: Constructor is called
2. When `function1()` ends: Object is destroyed, Destructor is called

## Rules for Writing Destructor

### 1. Name
- Same class name with **tilde (~)** at the beginning
- Example: If class name is `clsPerson`, Destructor is `~clsPerson()`

### 2. Constraints
- **Cannot do Overloading** for Destructor
- **Takes no parameters**
- **Returns no values**
- **Only one destructor** per class

### 3. Calling
- Called **automatically** before destroying the object
- **Last method** executed in the object

## Problem with Pointers

```cpp
#include <iostream>
#include <string>
using namespace std;

class clsPerson
{
public:
    clsPerson()
    {
        cout << "Hi, I am constructor" << endl;
    }

    ~clsPerson()
    {
        cout << "Hi, I am destructor" << endl;
    }
};

void function1()
{
    clsPerson person1;  // Regular object
}

void function2()
{
    clsPerson* person2 = new clsPerson();  // Object with pointer
    // No delete - This is wrong!
}

int main()
{
    function1();
    function2();
    
    return 0;
}
```

**Result:**
```
Hi, I am constructor
Hi, I am destructor
Hi, I am constructor
```

**Problem:** 
- `function1`: Regular object → Destructor is called
- `function2`: Object with pointer → **Destructor is NOT called!**

## Solution: Using delete

```cpp
void function2()
{
    clsPerson* person2 = new clsPerson();  // Object with pointer
    
    // Any code you want...
    
    delete person2;  // Manually destroy object
}
```

**Correct Result:**
```
Hi, I am constructor
Hi, I am destructor
Hi, I am constructor
Hi, I am destructor
```

## Golden Rule in C++

> **Every `new` must be followed by `delete`**

This avoids:
- **Memory Leaks**
- Program slowdown
- Memory exhaustion

## Uses of Destructor

Destructor can be used for:

### 1. Saving Data
```cpp
~clsPerson()
{
    // Save data to file or database
    saveToFile();
}
```

### 2. Closing Connections
```cpp
~clsPerson()
{
    // Close database connection
    closeDatabaseConnection();
}
```

### 3. Releasing Resources
```cpp
~clsPerson()
{
    // Release other objects
    delete relatedObject1;
    delete relatedObject2;
    delete relatedObject3;
}
```


## Summary

**Destructor** is:
- **Last method** called before destroying the object
- Used to clean up resources and save data
- Called **automatically** for regular objects
- Needs **manual delete** for objects created with pointers

**Important Rules:**
- Only one destructor per class
- Takes no parameters and returns no values
- Every `new` must be followed by `delete`

**Advice:** Use Destructor to clean up everything before leaving the object - "Enter clean and exit clean"


<br><br><br>
---

*Anas Chetoui - `anaschetoui`*
