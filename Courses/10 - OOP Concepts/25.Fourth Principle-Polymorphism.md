<a id="arabic"></a>
[English ↙](#english)

<div dir="rtl" style="text-align: right">

# المبدأ الرابع في البرمجة الكائنية: تعدد الأشكال
## Fourth Principle/Concept of OOP: Polymorphism

## مراجعة المبادئ السابقة

في الدروس السابقة تم تعلم ثلاثة مبادئ من مبادئ البرمجة الكائنية:

### 1. التغليف (Encapsulation)
- جمع جميع الطرق والمتغيرات تحت مظلة واحدة
- وضعها في كبسولة الفئة (Class)
- لا يمكن الوصول إليها إلا عن طريق الكائن (Object)

### 2. التجريد (Abstraction)
- إخفاء التفاصيل الداخلية للكود
- مثال: كائن String يحتوي على طرق وخصائص ظاهرة
- الطرق والخصائص الداخلية مخفية لأنها لا تهم المطور

### 3. الوراثة (Inheritance)
- وراثة الخصائص والطرق من فئة أساسية
- أنواع مختلفة من الوراثة

## المبدأ الرابع: تعدد الأشكال (Polymorphism)

### هل هو شيء جديد؟
ستفاجئون بأن الإجابة **لا**. جميع المفاهيم المتعلقة بتعدد الأشكال تم تعلمها وتطبيقها، لكن دون معرفة أن هذا اسمها Polymorphism.

### ما معنى Polymorphism؟
**Polymorphism يعني تعدد الأشكال**

## الرسم التوضيحي الأول

</div>

```
┌─────────────────────────────────────────────────────┐
│                   Polymorphism                      │
├─────────────────────────────────────────────────────┤
│                                                     │
│        Polymorphism means "many forms"              │
│                                                     │
│   Polymorphism allows us to create consistent code  │
│                                                     │
└─────────────────────────────────────────────────────┘
```

<div dir="rtl" style="text-align: right">

### تشبيه من الواقع: الإنسان ذو الوجهين

تخيل صديقاً لك:
- **أمامك:** يظهر وجهاً طيباً ويبدو أنه يحبك
- **خلفك:** يتحدث في ظهرك ويغتاب فيك

هذا الإنسان له **وجهان** أو **شكلان مختلفان**:
- وجه طيب ووجه سيء
- هذا ما نسميه **Polymorphism** - تعدد الأوجه أو تعدد الأشكال

### الهدف من Polymorphism

تعدد الأشكال موجود لجعل المطور يحصل على:
- **الاتساق في الكود (Consistency)**
- **معيار موحد (Standard) في الكود**
- **تقليل الأخطاء على المطور**
- **تقليل الحاجة لتذكر أشياء كثيرة**

## طرق تحقيق Polymorphism

### الرسم التوضيحي الثاني

</div>

```
┌─────────────────────────────────────────────────────┐
│         Polymorphism can be done through:           │
├─────────────────────────────────────────────────────┤
│                                                     │
│  ┌─────────────────────────────────────────────┐    │
│  │                                             │    │
│  │         Function overloading               │    │
│  │                                             │    │
│  │         Operator overloading               │    │
│  │                                             │    │
│  │         Function overriding                │    │
│  │                                             │    │
│  │         Virtual functions                  │    │
│  │                                             │    │
│  └─────────────────────────────────────────────┘    │
│                                                     │
└─────────────────────────────────────────────────────┘
```

<div dir="rtl" style="text-align: right">

تعدد الأشكال يمكن تحقيقه عن طريق أربع طرق (جميعها تم تعلمها سابقاً):

## 1. تحميل الدوال الزائد (Function Overloading)

### المثال المألوف:
- دالة `Sum` تأخذ معاملين → تجمع رقمين
- دالة `Sum` تأخذ ثلاثة معاملات → تجمع ثلاثة أرقام  
- دالة `Sum` تأخذ أربعة معاملات → تجمع أربعة أرقام

### النتيجة:
- **الاسم واحد:** `Sum`
- **الوظائف متعددة:** حسب عدد المعاملات
- **بدلاً من:** أربع دوال بأسماء مختلفة مثل:
  - `SumOfTwoNumbers`
  - `SumOfThreeNumbers`  
  - `SumOfFourNumbers`
  - `SumOfFiveNumbers`

### الفائدة:
- **اتساق في الكود:** اسم واحد لوظيفة واحدة
- **سهولة الاستخدام:** لا حاجة لتذكر أسماء متعددة
- **معيار موحد:** دالة `Sum` واحدة بوظائف متعددة

## 2. تحميل العمليات الزائد (Operator Overloading)

### أمثلة يومية:
- **مع الأرقام:** `var1 + var2` → جمع رياضي
- **مع النصوص:** `"محمد" + "أحمد"` → ربط النصوص (Concatenation)

### العملية:
- **نفس الرمز:** `+`
- **وظائف مختلفة:** جمع أو ربط حسب نوع البيانات
- **استخدام يومي:** يحدث تلقائياً دون تدخل المطور

## 3. تجاوز الدوال (Function Overriding)

### المثال المألوف:
- فئة `Person` تحتوي على دالة `Print`
- فئة `Employee` ترث من `Person` وتحتوي على `Print` معدلة
- فئة `Student` ترث من `Person` وتحتوي على `Print` معدلة
- فئة `Doctor` ترث من `Employee` وتحتوي على `Print` معدلة

### النتيجة:
- **اسم واحد:** `Print` في جميع الفئات
- **تنفيذ مختلف:** كل فئة تطبع معلوماتها الخاصة
- **بدلاً من:** أسماء مختلفة مثل:
  - `PrintPerson`
  - `PrintEmployee`
  - `PrintStudent`
  - `PrintDoctor`

### الفائدة:
- **اتساق في التسمية:** دالة `Print` واحدة
- **سهولة الاستخدام:** لا حاجة لتذكر أسماء متعددة
- **وضوح المفهوم:** الدالة تعرف ماذا تطبع حسب نوع الكائن

## 4. الدوال الافتراضية (Virtual Functions)

### الآلية:
- **مؤشرات الفئة الأساسية:** `Person* ptr`
- **الإشارة لكائنات مختلفة:** `ptr = &Employee1` أو `ptr = &Student1`
- **الاستدعاء الصحيح:** `ptr->Print()` تستدعي الدالة المناسبة

### النوع:
- **تعدد أشكال وقت التشغيل (Runtime Polymorphism)**
- **تحديد الدالة في وقت التشغيل:** وليس وقت التجميع

## الفوائد الشاملة لـ Polymorphism

### 1. الاتساق في الكود (Code Consistency)
- **نسق واحد:** جميع الدوال المشابهة لها نفس الاسم
- **معيار موحد:** مطورون مختلفون يستخدمون نفس التسمية

### 2. تقليل العبء على المطور
- **تذكر أقل:** اسم واحد بدلاً من أسماء متعددة
- **أخطاء أقل:** صعوبة أقل في كتابة الكود
- **فهم أسرع:** المفهوم واضح من الاسم

### 3. مرونة أكبر
- **نفس الواجهة:** طرق مختلفة للتنفيذ
- **توسع سهل:** إضافة وظائف جديدة دون تغيير الواجهة
- **صيانة أفضل:** تعديل التنفيذ دون تغيير الاستدعاء

## الخلاصة الشاملة

### ما هو Polymorphism؟
**تعدد الأشكال** - القدرة على استخدام **نفس الاسم** لأداء **وظائف مختلفة** حسب **الموقف** أو **نوع البيانات**.

### الهدف الأساسي:
- **كود متسق:** نسق واحد في جميع أنحاء المشروع
- **معيار موحد:** قواعد ثابتة للتسمية والاستخدام
- **سهولة الصيانة:** تعديل وتطوير أسهل

### الطرق الأربع:
1. **Function Overloading** - دوال متعددة بنفس الاسم
2. **Operator Overloading** - عمليات متعددة بنفس الرمز  
3. **Function Overriding** - تجاوز دوال الفئة الأساسية
4. **Virtual Functions** - تحديد الدالة في وقت التشغيل

### التذكير المهم:
**جميع هذه المفاهيم معروفة ومطبقة، والجديد فقط هو معرفة أنها تشكل مبدأ Polymorphism في البرمجة الكائنية.**

</div>

<br><br><br><br><br><br><br><br><br>

<a id="english"></a>
[العربية ↗](#arabic)

# Fourth Principle/Concept of OOP: Polymorphism

## Review of Previous Principles

In previous lessons, three principles of Object-Oriented Programming were learned:

### 1. Encapsulation
- Gathering all methods and variables under one umbrella
- Placing them in the Class capsule
- Can only be accessed through the Object

### 2. Abstraction  
- Hiding internal details of code
- Example: String object contains visible methods and properties
- Internal methods and properties are hidden because they don't concern the developer

### 3. Inheritance
- Inheriting properties and methods from a base class
- Different types of inheritance

## Fourth Principle: Polymorphism

### Is it something new?
You'll be surprised that the answer is **no**. All concepts related to Polymorphism have been learned and applied, but without knowing that this is called Polymorphism.

### What does Polymorphism mean?
**Polymorphism means many forms/shapes**

## First Visual Diagram

```
┌─────────────────────────────────────────────────────┐
│                   Polymorphism                      │
├─────────────────────────────────────────────────────┤
│                                                     │
│        Polymorphism means "many forms"              │
│                                                     │
│   Polymorphism allows us to create consistent code  │
│                                                     │
└─────────────────────────────────────────────────────┘
```

### Real-world Analogy: The Two-Faced Person

Imagine a friend of yours:
- **In front of you:** Shows a kind face and seems to love you
- **Behind you:** Talks behind your back and gossips about you

This person has **two faces** or **two different forms**:
- A good face and a bad face
- This is what we call **Polymorphism** - multiple faces or multiple forms

### Purpose of Polymorphism

Polymorphism exists to give developers:
- **Code Consistency**
- **Unified Standard in code**
- **Reducing errors for developers**
- **Reducing the need to remember many things**

## Ways to Achieve Polymorphism

### Second Visual Diagram

```
┌─────────────────────────────────────────────────────┐
│         Polymorphism can be done through:           │
├─────────────────────────────────────────────────────┤
│                                                     │
│  ┌─────────────────────────────────────────────┐    │
│  │                                             │    │
│  │         Function overloading               │    │
│  │                                             │    │
│  │         Operator overloading               │    │
│  │                                             │    │
│  │         Function overriding                │    │
│  │                                             │    │
│  │         Virtual functions                  │    │
│  │                                             │    │
│  └─────────────────────────────────────────────┘    │
│                                                     │
└─────────────────────────────────────────────────────┘
```

Polymorphism can be achieved through four ways (all previously learned):

## 1. Function Overloading

### Familiar Example:
- `Sum` function takes two parameters → adds two numbers
- `Sum` function takes three parameters → adds three numbers
- `Sum` function takes four parameters → adds four numbers

### Result:
- **One name:** `Sum`
- **Multiple functions:** based on number of parameters
- **Instead of:** four functions with different names like:
  - `SumOfTwoNumbers`
  - `SumOfThreeNumbers`
  - `SumOfFourNumbers`
  - `SumOfFiveNumbers`

### Benefit:
- **Code consistency:** one name for one concept
- **Ease of use:** no need to remember multiple names
- **Unified standard:** one `Sum` function with multiple capabilities

## 2. Operator Overloading

### Daily Examples:
- **With numbers:** `var1 + var2` → mathematical addition
- **With strings:** `"Mohammed" + "Ahmed"` → string concatenation

### Operation:
- **Same symbol:** `+`
- **Different functions:** addition or concatenation based on data type
- **Daily usage:** happens automatically without developer intervention

## 3. Function Overriding

### Familiar Example:
- `Person` class contains `Print` function
- `Employee` class inherits from `Person` and contains modified `Print`
- `Student` class inherits from `Person` and contains modified `Print`
- `Doctor` class inherits from `Employee` and contains modified `Print`

### Result:
- **One name:** `Print` in all classes
- **Different implementation:** each class prints its own information
- **Instead of:** different names like:
  - `PrintPerson`
  - `PrintEmployee`
  - `PrintStudent`
  - `PrintDoctor`

### Benefit:
- **Naming consistency:** one `Print` function
- **Ease of use:** no need to remember multiple names
- **Concept clarity:** function knows what to print based on object type

## 4. Virtual Functions

### Mechanism:
- **Base class pointers:** `Person* ptr`
- **Pointing to different objects:** `ptr = &Employee1` or `ptr = &Student1`
- **Correct calling:** `ptr->Print()` calls the appropriate function

### Type:
- **Runtime Polymorphism**
- **Function determination at runtime:** not compile time

## Comprehensive Benefits of Polymorphism

### 1. Code Consistency
- **One pattern:** all similar functions have the same name
- **Unified standard:** different developers use the same naming

### 2. Reducing Developer Burden
- **Less memorization:** one name instead of multiple names
- **Fewer errors:** less difficulty in writing code
- **Faster understanding:** concept is clear from the name

### 3. Greater Flexibility
- **Same interface:** different ways of implementation
- **Easy expansion:** adding new functions without changing interface
- **Better maintenance:** modifying implementation without changing calls

## Comprehensive Summary

### What is Polymorphism?
**Many forms** - the ability to use the **same name** to perform **different functions** based on **situation** or **data type**.

### Main Goal:
- **Consistent code:** one pattern throughout the project
- **Unified standard:** fixed rules for naming and usage
- **Easy maintenance:** easier modification and development

### Four Methods:
1. **Function Overloading** - multiple functions with same name
2. **Operator Overloading** - multiple operations with same symbol
3. **Function Overriding** - overriding base class functions
4. **Virtual Functions** - determining function at runtime

### Important Reminder:
**All these concepts are known and applied, what's new is just knowing that they constitute the Polymorphism principle in Object-Oriented Programming.**

<br><br><br>
---
*Anas Chetoui - `anaschetoui`*
