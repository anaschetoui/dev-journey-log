<a id="arabic"></a>
# البرمجة الشيئية (OOP)

### مقدمة: لماذا نحتاج إلى أسلوب جديد في البرمجة؟
[English](#english)

في أساليب البرمجة التقليدية، مثل البرمجة الوظيفية (Functional Programming)، كنا نقوم بكتابة الكود عبر تقسيمه إلى مجموعة كبيرة من الوظائف (Functions) المنفصلة. كل وظيفة تكون مسؤولة عن مهمة محددة، ويتم استدعاؤها بشكل متسلسل عند الحاجة. هذا الأسلوب يعمل بشكل جيد في المشاريع الصغيرة والبسيطة، ولكن تظهر مشاكله الحقيقية عند التعامل مع المشاريع الكبيرة والمعقدة.

### المشكلة: فوضى الوظائف في المشاريع الكبيرة
لنتخيل أننا نعمل على مشروع كبير مثل نظام إلكتروني لإدارة جامعة. باستخدام البرمجة الوظيفية، سنجد أنفسنا نكتب مئات أو حتى آلاف الوظائف المنفصلة للتعامل مع كل جزء من النظام، مثل:
* وظائف لإضافة الطلاب وحذفهم وتعديل بياناتهم.
* وظائف لإدارة الدكاترة والموظفين.
* وظائف لإرسال رسائل البريد الإلكتروني والرسائل النصية للطلاب والدكاترة.

**أين تكمن المشكلة؟**
المشكلة ليست في كثرة الوظائف بحد ذاتها، بل في أنها غير منظمة وموجودة كلها "تحت سقف واحد". هذا الوضع يؤدي إلى:
* **صعوبة الإدارة**: إدارة مئات الوظائف وتذكرها يصبح أمرًا صعبًا للغاية.
* **صعوبة الوصول**: إيجاد وظيفة معينة يصبح مهمة معقدة وسط هذا الكم الهائل من الكود.
* **فوضى غير قابلة للتوسع**: يصبح تطوير المشروع وإضافة مزايا جديدة شبه مستحيل مع هذا الأسلوب.

يمكن تشبيه الأمر بوجود آلاف من جهات الاتصال في هاتفك دون أي تنظيم أبجدي، مما يجعل العثور على اسم معين كابوسًا حقيقيًا.

### الحل: البرمجة الشيئية (OOP)
تقدم البرمجة الشيئية (Object-Oriented Programming) حلاً جذريًا لهذه المشكلة، فهي تغير طريقة تفكيرنا في كتابة الكود لتقترب أكثر من طريقة نظرنا إلى العالم الحقيقي. الفكرة المحورية هي:

> تعامل مع كل شيء على أنه "كائن" (Object).

بالعودة إلى مثال نظام الجامعة، بدلًا من التفكير في قائمة طويلة من الوظائف، نبدأ بالتفكير في "الأشياء" أو "الكائنات" التي يتكون منها النظام:
* كائن **الطالب** (`Student`)
* كائن **الدكتور** (`Doctor`)
* كائن **الموظف** (`Employee`)
* كائن **المساق** (`Course`)

أصبح تفكيرنا الآن أقرب للواقع، حيث ننظر لكل مكون من مكونات البرنامج كشيء مستقل بذاته.

### كيف تنظم البرمجة الشيئية الكود؟
الميزة الأساسية هنا هي أن كل "كائن" يصبح بمثابة حاوية أو مظلة خاصة به، تضم كل ما يتعلق به من بيانات ووظائف.

* **الكائن (Object)**: هو تمثيل لشيء معين، مثل "طالب" واحد.
* **الخصائص (Properties)**: هي البيانات التي تصف الكائن، مثل اسم الطالب وبريده الإلكتروني (`Student1.Name`, `Student1.Email`).
* **التوابع (Methods)**: هي الوظائف التي يمكن للكائن القيام بها، وفي البرمجة الشيئية يُطلق على الوظيفة اسم "Method". مثل حساب المعدل أو إرسال بريد إلكتروني (`Student1.CalculateAverage()`, `Student1.SendEmail()`).

بهذه الطريقة، تكون جميع الوظائف المتعلقة بالطلاب موجودة تحت مظلة "الطالب"، ولا يمكن أن تتداخل مع وظائف "الموظف" مثلًا. هذا يمنحنا:

1. **تنظيمًا فائقًا للكود.**
2. **سهولة في الوصول للوظائف وتذكرها.**
3. **قدرة على التعامل مع الكائن وكل وظائفه من مكان واحد.**

### مزايا إضافية: الحماية والأمان
من أكبر عيوب البرمجة التنفيذية (الإجرائية) هو أن أي جزء من الكود يمكنه استدعاء أي وظيفة والتلاعب بالبيانات مباشرة، مما يضعف أمان الكود. في المقابل، تمنحك البرمجة الشيئية القدرة على حماية الكود عن طريق منع استدعاء بعض الوظائف (Methods) من خارج الكائن (Class)، مما يوفر طبقة حماية قوية ومميزات أخرى عديدة.









<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<a id="english"></a>

[العربية](#arabic)

# Object-Oriented Programming (OOP)

### Why Do We Need a New Way of Programming?

In older programming styles, like **Functional Programming**, we wrote code by dividing it into many separate **functions**. Each function had one specific job and was called when needed. This method is fine for small and simple projects, but it causes real problems when projects get big and complex.

---

### The Problem: Too Many Functions in Large Projects

Imagine we are working on a big project, like a management system for a university. With functional programming, we would write hundreds or even thousands of separate functions for every part of the system, such as:

* Functions to add, delete, and edit student information.
* Functions to manage doctors and employees.
* Functions to send emails and text messages to students and doctors.

**So, what's the problem?**

The problem isn't the number of functions, but the fact that they are not organized and are all mixed together. This leads to several issues:

* **Difficult to Manage**: It becomes very hard to manage and remember hundreds of functions.
* **Hard to Access**: Finding a specific function in so much code is a difficult task.
* **Difficult to Expand**: It becomes almost impossible to grow the project and add new features using this method.

You can think of it like having thousands of contacts on your phone without any alphabetical order, which would make finding a specific name a real nightmare.

---

### The Solution: Object-Oriented Programming (OOP)

**Object-Oriented Programming (OOP)** offers a great solution to this problem. It changes how we think about code to make it more like the real world. The main idea is:

> Treat everything as an "Object."

Going back to the university system example, instead of thinking about a long list of functions, we start thinking about the "things" or "objects" that the system is made of:

* A **Student** object
* A **Doctor** object
* An **Employee** object
* A **Course** object

Now, our way of thinking is closer to reality because we see each part of the program as a separate thing.

---

### How Does OOP Organize Code?

The main advantage here is that each **object** acts as a container that holds all the data and functions related to it.

* **Object**: Represents a specific thing, like a single "student."
* **Properties**: The data that describes the object, like a student's name and email (`Student1.Name`, `Student1.Email`).
* **Methods**: The actions that the object can do. In OOP, a function is called a "Method," like calculating a student's average or sending an email (`Student1.CalculateAverage()`, `Student1.SendEmail()`).

This way, all the functions related to students are kept under the "Student" object and don't get mixed up with the "Employee" functions, for example. This gives us:

1.  **Excellent code organization.**
2.  **Easy access to functions.**
3.  **The ability to work with an object and all its functions from one place.**

---

### Extra Benefit: Protection and Security

One of the biggest problems with older programming styles is that any part of the code can call any function and change data directly, which makes the code less secure. In contrast, OOP lets you protect your code by preventing some methods from being called from outside the object (or **Class**), which provides a strong layer of security and many other benefits.
