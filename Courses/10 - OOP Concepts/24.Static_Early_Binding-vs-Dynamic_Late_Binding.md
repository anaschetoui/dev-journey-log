<a id="arabic"></a>
[English ↙](#english)

<div dir="rtl" style="text-align: right">

# الربط الثابت المبكر مقابل الربط الديناميكي المتأخر
## Static/Early Binding vs Dynamic/Late Binding

## مراجعة الدرس السابق

في الدرس السابق تم تعلم:
- **الدوال الافتراضية (Virtual Functions)** وآلية عملها
- **كيفية حل مشكلة المؤشرات** مع تجاوز الدوال (Override)
- **الجدول الافتراضي (Virtual Table)** وآلية عمل الدوال الافتراضية
- **استخدام الكلمة المفتاحية virtual** في الفئة الأساسية

## تعريف المصطلحات

### المصطلحات المترادفة:
- **Static Binding = Early Binding** (الربط الثابت = الربط المبكر)
- **Dynamic Binding = Late Binding** (الربط الديناميكي = الربط المتأخر)

هذا الموضوع معروف للمطورين لكن من الضروري معرفة أسماء هذه المفاهيم الصحيحة.

## الكود الأساسي من الدرس السابق

</div>

```cpp
class clsPerson
{
public:
    virtual void Print()
    {
        cout << "Hi, i'm a person!\n ";
    }
};

class clsEmployee : public clsPerson
{
public:
    void Print()
    {
        cout << "Hi, I'm an Employee\n";
    }
};

class clsStudent : public clsPerson
{
public:
    void Print() 
    {
        cout << "Hi, I'm a student\n";
    }
};
```

<div dir="rtl" style="text-align: right">

## تقسيم استدعاء الدوال (Function Calls)

موضوع استدعاء الدوال ينقسم إلى قسمين:
1. **الربط الثابت أو المبكر (Static أو Early Binding)**
2. **الربط الديناميكي أو المتأخر (Dynamic أو Late Binding)**

## الربط الثابت/المبكر (Static/Early Binding)

### المثال العملي:

</div>

```cpp
int main()
{
    clsEmployee Employee1;
    clsStudent Student1;
    
    // Early/Static Binding: at compilation time
    Employee1.Print();  // يستدعي Employee::Print()
    Student1.Print();   // يستدعي Student::Print()
    
    return 0;
}
```

<div dir="rtl" style="text-align: right">

### كيف يعمل الربط الثابت؟

1. **عند استدعاء `Employee1.Print()`:**
   - يتم استدعاء دالة Print الموجودة داخل فئة Employee
   - كيف تم تحديد ذلك؟ تم تحديده مسبقاً لأن الكائن من نوع Employee

2. **عند استدعاء `Student1.Print()`:**
   - يتم استدعاء دالة Print الموجودة داخل فئة Student
   - كيف تم تحديد ذلك؟ تم تحديده مسبقاً لأن الكائن من نوع Student

### لماذا يُسمى الربط المبكر/الثابت؟

- **المبكر (Early)** لأنه يتم تحديده مسبقاً في **وقت التجميع (Compile Time)**
- **الثابت (Static)** لأن العنوان ثابت ومعروف مسبقاً
- المترجم لديه معرفة مسبقة وصريحة بهذا الأمر

### تشبيه من الواقع:
مثل الرغبة في زيارة صديق والمعرفة المسبقة لعنوانه. العنوان معروف قبل مغادرة المنزل، فالأمور واضحة.

## الربط الديناميكي/المتأخر (Dynamic/Late Binding)

### المثال العملي:

</div>

```cpp
int main()
{
    clsEmployee Employee1;
    clsStudent Student1;
    
    // Up Casting - إنشاء المؤشرات
    clsPerson* Person1 = &Employee1;  // مؤشر Person يشير إلى Employee
    clsPerson* Person2 = &Student1;   // مؤشر Person يشير إلى Student
    
    // Late/Dynamic Binding: at runtime
    Person1->Print();  // يستدعي Employee::Print()
    Person2->Print();   // يستدعي Student::Print()
    
    return 0;
}
```

<div dir="rtl" style="text-align: right">

### كيف يعمل الربط الديناميكي؟

1. **المشكلة:**
   - المترجم لا يعرف عنوان دالة Employee
   - ولا يعرف عنوان دالة Student
   - لأن هذا مؤشر (Pointer)

2. **الحل:**
   - عند تشغيل البرنامج، يشير المؤشر إلى Employee
   - يحدث الربط في **وقت التشغيل (Runtime)**
   - يتم التعرف على العنوان في وقت التشغيل عن طريق **الجدول الافتراضي (Virtual Table)**

### لماذا يُسمى الربط المتأخر/الديناميكي؟

- **المتأخر (Late)** لأنه يتم معرفة العنوان متأخراً (في وقت التشغيل)
- **الديناميكي (Dynamic)** لأنه يتم معرفة العنوان بشكل ديناميكي، وليس بشكل ثابت
- في وقت التشغيل يتم معرفة العنوان متأخراً

### تشبيه من الواقع:
مثل دعوة صديق للزيارة دون معرفة عنوانه. يتم الخروج وقيادة السيارة، وأثناء الطريق يتم الاتصال بالصديق لمعرفة العنوان. ففي وقت التشغيل (أثناء القيادة) يتم معرفة العنوان.

## المقارنة التفصيلية

### الرسم التوضيحي:

</div>

```
الربط الثابت/المبكر (وقت التجميع):
┌─────────────────────────────────────────────────────┐
│              في وقت التجميع                        │
├─────────────────────────────────────────────────────┤
│                                                     │
│ Employee1.Print() ───► Employee::Print()            │
│        ↑                                            │
│   عنوان معروف مسبقاً                               │
│                                                     │
│ Student1.Print() ────► Student::Print()             │
│        ↑                                            │
│   عنوان معروف مسبقاً                               │
│                                                     │
└─────────────────────────────────────────────────────┘

الربط الديناميكي/المتأخر (وقت التشغيل):
┌─────────────────────────────────────────────────────┐
│                في وقت التشغيل                      │
├─────────────────────────────────────────────────────┤
│                                                     │
│ Person1->Print() ────► Virtual Table ────► Employee::Print() │
│        ↑                     ↑                      │
│   مؤشر غير محدد       يحدد العنوان في وقت التشغيل   │
│                                                     │
│ Person2->Print() ────► Virtual Table ────► Student::Print()  │
│        ↑                     ↑                      │
│   مؤشر غير محدد       يحدد العنوان في وقت التشغيل   │
│                                                     │
└─────────────────────────────────────────────────────┘
```

<div dir="rtl" style="text-align: right">

## جدول المقارنة الشامل

| الخاصية | الربط الثابت/المبكر | الربط الديناميكي/المتأخر |
|---------|---------------------|---------------------|
| **وقت التحديد** | وقت التجميع | وقت التشغيل |
| **السرعة** | أسرع قليلاً | أبطأ قليلاً |
| **الآلية** | عنوان مباشر | الجدول الافتراضي |
| **نوع الاستدعاء** | Object.Method() | Pointer->Method() |
| **المرونة** | محدودة | عالية |
| **استخدام الذاكرة** | أقل | جدول افتراضي إضافي |

## متى يحدث كل نوع؟

### الربط الثابت/المبكر يحدث مع:
- **الاستدعاء المباشر للكائنات:** `Employee1.Print()`
- **أي شيء غير افتراضي (Non-Virtual)** وبدون استخدام مؤشر
- **جميع الدوال والفئات** العادية

### الربط الديناميكي/المتأخر يحدث مع:
- **الدوال الافتراضية (Virtual Functions)** مع المؤشرات
- **استخدام التحويل التصاعدي (Up Casting):** `clsPerson* ptr = &Employee1;`
- **الاستدعاء من خلال مؤشرات الفئة الأساسية**

## الفروق في الأداء

### الربط الثابت:
- **أسرع** لأن العنوان معروف مسبقاً
- **لا توجد خطوات إضافية** في وقت التشغيل
- **استهلاك ذاكرة أقل**

### الربط الديناميكي:
- **أبطأ قليلاً** بسبب البحث في الجدول الافتراضي
- **خطوات إضافية** في وقت التشغيل
- **استهلاك ذاكرة إضافي** للجدول الافتراضي

## الكود الشامل مع التوضيحات

</div>

```cpp
#include <iostream>
using namespace std;

class clsPerson
{
public:
    virtual void Print()
    {
        cout << "Hi, i'm a person!\n ";
    }
};

class clsEmployee : public clsPerson
{
public:
    void Print()
    {
        cout << "Hi, I'm an Employee\n";
    }
};

class clsStudent : public clsPerson
{
public:
    void Print() 
    {
        cout << "Hi, I'm a student\n";
    }
};

int main()
{
    clsEmployee Employee1;
    clsStudent Student1;
    
    // Early/Static Binding: at compilation time
    cout << "=== الربط الثابت/المبكر ===" << endl;
    Employee1.Print();  // عنوان معروف في وقت التجميع
    Student1.Print();   // عنوان معروف في وقت التجميع
    
    cout << "\n=== الربط الديناميكي/المتأخر ===" << endl;
    clsPerson* Person1 = &Employee1;
    clsPerson* Person2 = &Student1;
    
    // Late/Dynamic Binding: at runtime
    Person1->Print();   // عنوان يُحدد في وقت التشغيل عبر الجدول الافتراضي
    Person2->Print();   // عنوان يُحدد في وقت التشغيل عبر الجدول الافتراضي
    
    return 0;
}
```

<div dir="rtl" style="text-align: right">

## الخلاصة النهائية

### القاعدة الأساسية:
- **معرفة عنوان الدالة ضرورية لاستدعائها**
- **إذا كان التحديد في وقت التشغيل** ← الربط الديناميكي/المتأخر
- **إذا كان التحديد في وقت التجميع** ← الربط الثابت/المبكر

### إرشادات عملية:
1. **استخدام الربط الثابت** عند عدم الحاجة لمرونة إضافية
2. **استخدام الربط الديناميكي** عند الحاجة لتعدد الأشكال (Polymorphism)
3. **مراعاة الأداء** عند اختيار النهج المناسب

### النقاط المحورية:
- **الربط الثابت/المبكر** = عنوان معروف مسبقاً = أداء أسرع
- **الربط الديناميكي/المتأخر** = عنوان يُحدد في وقت التشغيل = مرونة أكبر

</div>

<br><br><br><br><br><br><br><br><br>

<a id="english"></a>
[العربية ↗](#arabic)

# Static/Early Binding vs Dynamic/Late Binding

## Review of Previous Lesson

In the previous lesson, the following concepts were learned:
- **Virtual Functions** and their mechanisms
- **How to solve pointer problems** with Override
- **Virtual Table** and how virtual functions work
- **Using the virtual keyword** in the base class

## Term Definitions

### Synonymous Terms:
- **Static Binding = Early Binding** (same concept)
- **Dynamic Binding = Late Binding** (same concept)

This topic is known to developers, but it's essential to know the correct names of these concepts.

## Basic Code from Previous Lesson

```cpp
class clsPerson
{
public:
    virtual void Print()
    {
        cout << "Hi, i'm a person!\n ";
    }
};

class clsEmployee : public clsPerson
{
public:
    void Print()
    {
        cout << "Hi, I'm an Employee\n";
    }
};

class clsStudent : public clsPerson
{
public:
    void Print() 
    {
        cout << "Hi, I'm a student\n";
    }
};
```

## Function Calls Division

Function calling is divided into two sections:
1. **Static or Early Binding**
2. **Dynamic or Late Binding**

## Static/Early Binding

### Practical Example:

```cpp
int main()
{
    clsEmployee Employee1;
    clsStudent Student1;
    
    // Early/Static Binding: at compilation time
    Employee1.Print();  // Calls Employee::Print()
    Student1.Print();   // Calls Student::Print()
    
    return 0;
}
```

### How Does Static Binding Work?

1. **When calling `Employee1.Print()`:**
   - The Print function inside the Employee class is called
   - How was this determined? It was determined beforehand because the object is of type Employee

2. **When calling `Student1.Print()`:**
   - The Print function inside the Student class is called
   - How was this determined? It was determined beforehand because the object is of type Student

### Why Is It Called Early/Static Binding?

- **Early** because it's determined beforehand at **Compile Time**
- **Static** because the address is fixed and known beforehand
- The compiler has prior and explicit knowledge of this matter

### Real-world Analogy:
Like wanting to visit a friend with prior knowledge of their address. The address is known before leaving home, so everything is clear.

## Dynamic/Late Binding

### Practical Example:

```cpp
int main()
{
    clsEmployee Employee1;
    clsStudent Student1;
    
    // Up Casting - Creating pointers
    clsPerson* Person1 = &Employee1;  // Person pointer points to Employee
    clsPerson* Person2 = &Student1;   // Person pointer points to Student
    
    // Late/Dynamic Binding: at runtime
    Person1->Print();  // Calls Employee::Print()
    Person2->Print();   // Calls Student::Print()
    
    return 0;
}
```

### How Does Dynamic Binding Work?

1. **The Problem:**
   - The compiler doesn't know the address of the Employee function
   - Nor does it know the address of the Student function
   - Because this is a Pointer

2. **The Solution:**
   - When the program runs, the pointer points to Employee
   - Binding occurs at **Runtime**
   - The address is recognized at runtime through the **Virtual Table**

### Why Is It Called Late/Dynamic Binding?

- **Late** because the address is known late (at runtime)
- **Dynamic** because the address is known dynamically, not statically
- At runtime, the address is known late

### Real-world Analogy:
Like a friend inviting you to visit without knowing their address. You leave and drive the car, and during the journey, you call the friend to know the address. So at runtime (while driving), the address becomes known.

## Detailed Comparison

### Visual Diagram:

```
Static/Early Binding (Compile Time):
┌─────────────────────────────────────────────────────┐
│                At Compile Time                       │
├─────────────────────────────────────────────────────┤
│                                                     │
│ Employee1.Print() ───► Employee::Print()            │
│        ↑                                            │
│   Address known beforehand                          │
│                                                     │
│ Student1.Print() ────► Student::Print()             │
│        ↑                                            │
│   Address known beforehand                          │
│                                                     │
└─────────────────────────────────────────────────────┘

Dynamic/Late Binding (Runtime):
┌─────────────────────────────────────────────────────┐
│                  At Runtime                          │
├─────────────────────────────────────────────────────┤
│                                                     │
│ Person1->Print() ────► Virtual Table ────► Employee::Print() │
│        ↑                     ↑                      │
│   Undefined pointer    Determines address at Runtime │
│                                                     │
│ Person2->Print() ────► Virtual Table ────► Student::Print()  │
│        ↑                     ↑                      │
│   Undefined pointer    Determines address at Runtime │
│                                                     │
└─────────────────────────────────────────────────────┘
```

## Comprehensive Comparison Table

| Property | Static/Early Binding | Dynamic/Late Binding |
|----------|---------------------|---------------------|
| **Determination Time** | Compile Time | Runtime |
| **Speed** | Slightly faster | Slightly slower |
| **Mechanism** | Direct address | Virtual Table |
| **Call Type** | Object.Method() | Pointer->Method() |
| **Flexibility** | Limited | High |
| **Memory Usage** | Less | Additional Virtual Table |

## When Does Each Type Occur?

### Static/Early Binding occurs with:
- **Direct object calls:** `Employee1.Print()`
- **Anything non-Virtual** without using pointers
- **All regular functions and classes**

### Dynamic/Late Binding occurs with:
- **Virtual Functions** with pointers
- **Using Up Casting:** `clsPerson* ptr = &Employee1;`
- **Calling through base class pointers**

## Performance Differences

### Static Binding:
- **Faster** because the address is known beforehand
- **No additional steps** at runtime
- **Less memory consumption**

### Dynamic Binding:
- **Slightly slower** due to Virtual Table lookup
- **Additional steps** at runtime
- **Additional memory consumption** for the Virtual Table

## Comprehensive Code with Explanations

```cpp
#include <iostream>
using namespace std;

class clsPerson
{
public:
    virtual void Print()
    {
        cout << "Hi, i'm a person!\n ";
    }
};

class clsEmployee : public clsPerson
{
public:
    void Print()
    {
        cout << "Hi, I'm an Employee\n";
    }
};

class clsStudent : public clsPerson
{
public:
    void Print() 
    {
        cout << "Hi, I'm a student\n";
    }
};

int main()
{
    clsEmployee Employee1;
    clsStudent Student1;
    
    // Early/Static Binding: at compilation time
    cout << "=== Static/Early Binding ===" << endl;
    Employee1.Print();  // Address known at compile time
    Student1.Print();   // Address known at compile time
    
    cout << "\n=== Dynamic/Late Binding ===" << endl;
    clsPerson* Person1 = &Employee1;
    clsPerson* Person2 = &Student1;
    
    // Late/Dynamic Binding: at runtime
    Person1->Print();   // Address determined at runtime via Virtual Table
    Person2->Print();   // Address determined at runtime via Virtual Table
    
    return 0;
}
```

## Final Summary

### Basic Rule:
- **Knowing the function address is necessary for calling it**
- **If determination is at runtime** ← Dynamic/Late Binding
- **If determination is at compile time** ← Static/Early Binding

### Practical Guidelines:
1. **Use Static Binding** when additional flexibility is not needed
2. **Use Dynamic Binding** when Polymorphism is required
3. **Consider performance** when choosing the appropriate approach

### Key Points:
- **Static/Early Binding** = address known beforehand = faster performance
- **Dynamic/Late Binding** = address determined at runtime = greater flexibility

*Anas Chetoui - `anaschetoui`*
