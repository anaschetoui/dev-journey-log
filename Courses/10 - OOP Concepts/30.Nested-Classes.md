<a id="arabic"></a>
[English ↙](#english)

<div dir="rtl" style="text-align: right;">

# الفئات المتداخلة (Nested Classes)

## مراجعة الدرس السابق

في الدرس الماضي طرحنا سؤالاً منطقياً: **هل نستطيع تعريف بنية (Structure) داخل فئة (Class)؟**

**كان الجواب:** نعم، لأن البنية هي نوع بيانات (Data Type).

## سؤال اليوم: الانتقال من البنية إلى الفئة

**السؤال الجديد:** هل بإمكاني تعريف فئة داخل فئة؟ أي الفئات المتداخلة (Nested Classes)؟

**الجواب:** نعم! لماذا؟

- **الفئة هي نوع بيانات** - مثل Integer وBoolean وString وStructure
- لا يوجد شيء يمنعني من تعريف فئة داخل فئة أخرى

## التطور من البنية إلى الفئة المتداخلة

### المثال السابق: بنية العنوان

</div>

```cpp
// الطريقة القديمة - البنية
struct stAddress
{
    string AddressLine1;
    string AddressLine2;  
    string City;
    string Country;
};
```

<div dir="rtl" style="text-align: right;">

### المثال الجديد: فئة العنوان المتداخلة

</div>

```cpp
class clsPerson {
    
    // فئة داخل فئة - الفئة المتداخلة
    class clsAddress
    {
    public:
        string AddressLine1;
        string AddressLine2;
        string City;
        string Country;
      
        // دالة خاصة بالعنوان
        void Print()
        {
            cout << "\nAddress:\n";
            cout << AddressLine1 << endl;
            cout << AddressLine2 << endl;
            cout << City << endl;
            cout << Country << endl;
        }
    };

public:
    string FullName;
    clsAddress Address;  // كائن من نوع clsAddress

    clsPerson()
    {
        FullName = "Anas Chetoui";
        Address.AddressLine1 = "Building 15";
        Address.AddressLine2 = "Tech District";
        Address.City = "Riyadh";
        Address.Country = "Saudi Arabia";
    }
};
```

<div dir="rtl" style="text-align: right;">

## المفاهيم الأساسية

### 1. فئة الاحتواء (Enclosure Class)
- **clsPerson** هي فئة الاحتواء
- تحتوي على الفئة الداخلية

### 2. الفئة الداخلية (Inner Class)  
- **clsAddress** هي الفئة الداخلية
- موجودة داخل clsPerson

### 3. الوصول المحسّن
**الطريقة القديمة:**

</div>

```cpp
Person1.PrintAddress();  // دالة في فئة Person
```

<div dir="rtl" style="text-align: right;">

**الطريقة الجديدة:**

</div>

```cpp
Person1.Address.Print();  // دالة في فئة Address نفسها!
```

<div dir="rtl" style="text-align: right;">

## الاستخدام في البرنامج

</div>

```cpp
int main() 
{
    clsPerson Person1;
   
    // الوصول للخصائص المتداخلة
    cout << "Name: " << Person1.FullName << endl;
    cout << "City: " << Person1.Address.City << endl;
    
    // استدعاء دالة خاصة بالعنوان
    Person1.Address.Print();

    system("pause>0");
    return 0;
}
```

<div dir="rtl" style="text-align: right;">

## المزايا والتحسينات

### 1. تنظيم أفضل للكود
- **دالة Print** الآن تخصّ العنوان وليس الشخص
- كل فئة لها دوالها الخاصة بها

### 2. وصول منطقي أكثر

</div>

```cpp
Person1.Address.Print();        // منطقي - العنوان يطبع نفسه
Person1.Address.AddressLine1;   // وصول مباشر للخصائص
```

<div dir="rtl" style="text-align: right;">

### 3. إمكانيات الفئة الكاملة
- يمكن إضافة **منشئ (Constructor)** لـ clsAddress
- يمكن تعريف **أعضاء خاصة (Private Members)**
- يمكن إضافة **خصائص (Properties)** للقراءة والكتابة
- جميع مفاهيم البرمجة الكائنية متاحة!

## مثال متقدم: إضافة منشئ

</div>

```cpp
class clsPerson {
    
    class clsAddress
    {
    private:
        string _addressLine1;  // عضو خاص
        string _addressLine2;
        
    public:
        string City;
        string Country;
        
        // منشئ للعنوان
        clsAddress(string line1, string line2, string city, string country)
        {
            _addressLine1 = line1;
            _addressLine2 = line2;
            City = city;
            Country = country;
        }
        
        // دوال القراءة
        string GetAddressLine1() { return _addressLine1; }
        string GetAddressLine2() { return _addressLine2; }
      
        void Print()
        {
            cout << "\nAddress:\n";
            cout << _addressLine1 << endl;
            cout << _addressLine2 << endl;
            cout << City << endl;
            cout << Country << endl;
        }
    };

public:
    string FullName;
    clsAddress Address;

    clsPerson() : Address("Building 15", "Tech District", "Riyadh", "Saudi Arabia")
    {
        FullName = "Anas Chetoui";
    }
};
```

<div dir="rtl" style="text-align: right;">

## الرسم التوضيحي: الفئات المتداخلة

</div>

```
┌─────────────────────────────────────────────────────┐
│                  clsPerson                          │
│              (فئة الاحتواء)                          │
├─────────────────────────────────────────────────────┤
│                                                     │
│  ┌─────────────────────────────────────────────┐    │
│  │              clsAddress                     │    │
│  │            (الفئة الداخلية)                  │    │
│  ├─────────────────────────────────────────────┤    │
│  │ • AddressLine1                              │    │
│  │ • AddressLine2                              │    │
│  │ • City                                      │    │
│  │ • Country                                   │    │
│  │ • Print()                                   │    │
│  └─────────────────────────────────────────────┘    │
│                                                     │
│  • FullName                                         │
│  • Address (كائن من clsAddress)                    │
│                                                     │
└─────────────────────────────────────────────────────┘

الوصول: Person1.Address.Print()
        Person1.Address.City
```

<div dir="rtl" style="text-align: right;">

## النتيجة المتوقعة

</div>

```
Name: Anas Chetoui
City: Riyadh

Address:
Building 15
Tech District
Riyadh
Saudi Arabia
```

<div dir="rtl" style="text-align: right;">

## الخلاصة

### التطور الطبيعي:
1. **بنية داخل فئة** ← الدرس السابق
2. **فئة داخل فئة** ← درس اليوم  

### المزايا:
- **تنظيم أفضل:** كل فئة لها دوالها الخاصة بها
- **وصول منطقي:** `Person1.Address.Print()`
- **إمكانيات كاملة:** منشئات، أعضاء خاصة، خصائص
- **تطبيق مبادئ البرمجة الكائنية:** التغليف، الدوال، التحكم في الوصول

### النقطة المهمة:
**الفئة هي نوع بيانات** - لذلك يمكن تعريفها داخل فئة أخرى بدون أي مشكلة!

</div>

<br><br><br><br><br><br><br><br><br>

<a id="english"></a>
[العربية ↗](#arabic)

# Nested Classes

## Review of Previous Lesson

In the last lesson, we asked a logical question: **Can we define Structure inside Class?**

**The answer was:** Yes, because Structure is a Data Type.

## Today's Question: Transition from Structure to Class

**New Question:** Can I define Class inside Class? Meaning Nested Classes?

**Answer:** Yes! Why?

- **Class is a Data Type** - like Integer, Boolean, String, Structure
- Nothing prevents me from defining Class inside Class

## Evolution from Structure to Nested Class

### Previous Example: Structure Address

```cpp
// Old way - Structure
struct stAddress
{
    string AddressLine1;
    string AddressLine2;  
    string City;
    string Country;
};
```

### New Example: Nested Class Address

```cpp
class clsPerson {
    
    // Class inside Class - Nested Class
    class clsAddress
    {
    public:
        string AddressLine1;
        string AddressLine2;
        string City;
        string Country;
      
        // Method specific to Address
        void Print()
        {
            cout << "\nAddress:\n";
            cout << AddressLine1 << endl;
            cout << AddressLine2 << endl;
            cout << City << endl;
            cout << Country << endl;
        }
    };

public:
    string FullName;
    clsAddress Address;  // Object of type clsAddress

    clsPerson()
    {
        FullName = "Anas Chetoui";
        Address.AddressLine1 = "Building 15";
        Address.AddressLine2 = "Tech District";
        Address.City = "Riyadh";
        Address.Country = "Saudi Arabia";
    }
};
```

## Basic Concepts

### 1. Enclosure Class (Container Class)
- **clsPerson** is the Enclosure Class
- Contains the inner class

### 2. Inner Class (Nested Class)  
- **clsAddress** is the Inner Class
- Located inside clsPerson

### 3. Enhanced Access
**Old Way:**

```cpp
Person1.PrintAddress();  // Method in Person Class
```

**New Way:**

```cpp
Person1.Address.Print();  // Method in Address Class itself!
```

## Usage in Program

```cpp
int main() 
{
    clsPerson Person1;
   
    // Access nested properties
    cout << "Name: " << Person1.FullName << endl;
    cout << "City: " << Person1.Address.City << endl;
    
    // Call Address-specific method
    Person1.Address.Print();

    system("pause>0");
    return 0;
}
```

## Advantages and Improvements

### 1. Better Code Organization
- **Print Method** now belongs to Address, not Person
- Each class has its own methods

### 2. More Logical Access

```cpp
Person1.Address.Print();        // Logical - Address prints itself
Person1.Address.AddressLine1;   // Direct access to properties
```

### 3. Full Class Capabilities
- Can add **Constructor** to clsAddress
- Can define **Private Members**
- Can add **Properties** (Get/Set)
- All Object Oriented concepts available!

## Advanced Example: Adding Constructor

```cpp
class clsPerson {
    
    class clsAddress
    {
    private:
        string _addressLine1;  // Private member
        string _addressLine2;
        
    public:
        string City;
        string Country;
        
        // Constructor for Address
        clsAddress(string line1, string line2, string city, string country)
        {
            _addressLine1 = line1;
            _addressLine2 = line2;
            City = city;
            Country = country;
        }
        
        // Getter Methods
        string GetAddressLine1() { return _addressLine1; }
        string GetAddressLine2() { return _addressLine2; }
      
        void Print()
        {
            cout << "\nAddress:\n";
            cout << _addressLine1 << endl;
            cout << _addressLine2 << endl;
            cout << City << endl;
            cout << Country << endl;
        }
    };

public:
    string FullName;
    clsAddress Address;

    clsPerson() : Address("Building 15", "Tech District", "Riyadh", "Saudi Arabia")
    {
        FullName = "Anas Chetoui";
    }
};
```

## Visual Diagram: Nested Classes

```
┌─────────────────────────────────────────────────────┐
│                  clsPerson                          │
│                (Enclosure Class)                    │
├─────────────────────────────────────────────────────┤
│                                                     │
│  ┌─────────────────────────────────────────────┐    │
│  │              clsAddress                     │    │
│  │            (Inner Class)                    │    │
│  ├─────────────────────────────────────────────┤    │
│  │ • AddressLine1                              │    │
│  │ • AddressLine2                              │    │
│  │ • City                                      │    │
│  │ • Country                                   │    │
│  │ • Print()                                   │    │
│  └─────────────────────────────────────────────┘    │
│                                                     │
│  • FullName                                         │
│  • Address (object of clsAddress)                   │
│                                                     │
└─────────────────────────────────────────────────────┘

Access: Person1.Address.Print()
        Person1.Address.City
```

## Expected Output

```
Name: Anas Chetoui
City: Riyadh

Address:
Building 15
Tech District  
Riyadh
Saudi Arabia
```

## Summary

### Natural Evolution:
1. **Structure inside Class** ← Previous lesson
2. **Class inside Class** ← Today's lesson  

### Advantages:
- **Better Organization:** Each class has its own methods
- **Logical Access:** `Person1.Address.Print()`
- **Full Capabilities:** Constructors, Private Members, Properties
- **Apply OOP Principles:** Encapsulation, Methods, Access Control

### Key Point:
**Class is a Data Type** - therefore it can be defined inside another Class without any problem!

<br><br><br>
---
*Anas Chetoui - `anaschetoui`*
