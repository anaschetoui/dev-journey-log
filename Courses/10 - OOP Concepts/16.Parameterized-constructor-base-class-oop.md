<a id="arabic"></a>
[English ↙](#english)

<div dir="rtl" style="text-align: right">

# Parameterized Constructor of the Base Class

## مراجعة الدرس السابق

في الدرس السابق تعلمنا:
- **Inheritance:** مبدأ الوراثة في الـ OOP
- **Base Class vs Derived Class:** الفرق بين الكلاس الأم والمشتق
- **مشكلة Constructor:** واجهنا مشكلة مع الـ Parameterized Constructor

## المشكلة التي واجهناها

في الدرس السابق، عندما أردنا إنشاء object من `clsEmployee`:

</div>

```cpp
clsEmployee employee1;  // خطأ!
```

<div dir="rtl" style="text-align: right">

**رسالة الخطأ:**

</div>

```
The default constructor of clsEmployee cannot be referenced - it's deleted function
```

<div dir="rtl" style="text-align: right">

## سبب المشكلة

**المشكلة:** 
- الـ `clsPerson` (Base Class) فيها **Parameterized Constructor** فقط
- لا يوجد **Default Constructor**
- الـ `clsEmployee` (Derived Class) تحاول استدعاء Default Constructor للـ Parent

**الحل المؤقت الذي استخدمناه:**

</div>

```cpp
// أضفنا Default Constructor مؤقتاً
clsPerson()
{
    // فاضي - workaround
}
```

<div dir="rtl" style="text-align: right">

## الحل الصحيح

اليوم سنتعلم الحل الصحيح **بدون Default Constructor**:

### المبدأ:
- الـ Derived Class تستدعي الـ Base Class Constructor مباشرة
- تمرر له الـ parameters المطلوبة
- تُعامل parameters الإضافية بنفسها

## مثال عملي

</div>

```cpp
#include <iostream>
using namespace std;

// Base Class - بدون Default Constructor
class clsPerson
{
private:
    int _ID;
    string _FirstName;
    string _LastName;
    string _Email;
    string _Phone;

public:
    // Parameterized Constructor فقط
    clsPerson(int ID, string FirstName, string LastName, string Email, string Phone)
    {
        _ID = ID;
        _FirstName = FirstName;
        _LastName = LastName;
        _Email = Email;
        _Phone = Phone;
    }

    // Read Only Property
    int ID()
    {
        return _ID;
    }

    // Property Set
    void setFirstName(string FirstName)
    {
        _FirstName = FirstName;
    }

    // Property Get
    string FirstName()
    {
        return _FirstName;
    }

    // Property Set
    void setLastName(string LastName)
    {
        _LastName = LastName;
    }

    // Property Get
    string LastName()
    {
        return _LastName;
    }

    // Property Set
    void setEmail(string Email)
    {
        _Email = Email;
    }

    // Property Get
    string Email()
    {
        return _Email;
    }

    // Property Set
    void setPhone(string Phone)
    {
        _Phone = Phone;
    }

    // Property Get
    string Phone()
    {
        return _Phone;
    }

    string FullName()
    {
        return _FirstName + " " + _LastName;
    }

    void Print()
    {
        cout << "\nInfo:";
        cout << "\n___________________";
        cout << "\nID       : " << _ID;
        cout << "\nFirstName: " << _FirstName;
        cout << "\nLastName : " << _LastName;
        cout << "\nFull Name: " << FullName();
        cout << "\nEmail    : " << _Email;
        cout << "\nPhone    : " << _Phone;
        cout << "\n___________________\n";
    }

    void SendEmail(string Subject, string Body)
    {
        cout << "\nThe following message sent successfully to email: " << _Email;
        cout << "\nSubject: " << Subject;
        cout << "\nBody: " << Body << endl;
    }

    void SendSMS(string TextMessage)
    {
        cout << "\nThe following SMS sent successfully to phone: " << _Phone;
        cout << "\n" << TextMessage << endl;
    }
};

// Derived Class مع Constructor صحيح
class clsEmployee : public clsPerson
{
private:
    string _Title;
    string _Department;
    float _Salary;

public:
    // Constructor للـ Employee - الحل الصحيح
    clsEmployee(int ID, string FirstName, string LastName, string Email, string Phone,
               string Title, string Department, float Salary) 
        : clsPerson(ID, FirstName, LastName, Email, Phone)
    {
        // تعامل مع الخصائص الإضافية للـ Employee
        _Title = Title;
        _Department = Department;
        _Salary = Salary;
    }

    // Property Set
    void setTitle(string Title)
    {
        _Title = Title;
    }

    // Property Get
    string Title()
    {
        return _Title;
    }

    // Property Set
    void setDepartment(string Department)
    {
        _Department = Department;
    }

    // Property Get
    string Department()
    {
        return _Department;
    }

    // Property Set
    void setSalary(float Salary)
    {
        _Salary = Salary;
    }

    // Property Get
    float Salary()
    {
        return _Salary;
    }
};

int main()
{
    // الآن يمكن إنشاء Employee object بشكل صحيح
    clsEmployee Employee1(10, "Anas", "Chetoui", "anas@chetoui.com", 
                         "8298982", "CEO", "ProgrammingAdvices", 5000);

    Employee1.Print();
    
    // طباعة الخصائص الإضافية (حل مؤقت)
    cout << "\n" << Employee1.Title() << endl;
    cout << "\n" << Employee1.Department() << endl;
    cout << "\n" << Employee1.Salary() << endl;

    return 0;
}
```

<div dir="rtl" style="text-align: right">

## تحليل الحل

### السينتكس:

</div>

```cpp
clsEmployee(parameters...) : clsPerson(base_parameters)
{
    // تعامل مع خصائص الـ derived class
}
```

<div dir="rtl" style="text-align: right">

### التفسير:
1. **Constructor Name:** نفس اسم الكلاس (`clsEmployee`)
2. **Parameters:** كل الـ parameters المطلوبة (للـ base و derived)
3. **Colon (`:`):** فاصل للـ initialization list
4. **Base Constructor Call:** `clsPerson(parameters)`
5. **Body:** تعامل مع خصائص الـ derived class فقط

## كيف يعمل؟

### المراحل:
1. **تلقي الـ Parameters:** Constructor يتلقى كل الـ parameters
2. **تمرير للـ Base:** parameters الـ Person تُمرر للـ `clsPerson`
3. **Base Initialization:** `clsPerson` constructor ينفذ
4. **Derived Initialization:** كود الـ `clsEmployee` ينفذ

### مثال بالتفصيل:

</div>

```cpp
// عند الاستدعاء
clsEmployee Employee1(10, "Anas", "Chetoui", "anas@chetoui.com", "8298982",
                     "CEO", "ProgrammingAdvices", 5000);

// ما يحدث داخلياً:
// 1. Employee constructor يبدأ
// 2. clsPerson(10, "Anas", "Chetoui", "anas@chetoui.com", "8298982") ينفذ
// 3. Person object initialized بالكامل
// 4. Employee specific code ينفذ:
//    _Title = "CEO"
//    _Department = "ProgrammingAdvices" 
//    _Salary = 5000
// 5. Employee object جاهز للاستخدام
```

<div dir="rtl" style="text-align: right">

## فوائد هذا الحل

### 1. لا حاجة لـ Default Constructor
- تجبر على إرسال كل البيانات المطلوبة
- تضمن تهيئة كاملة للـ object
- تمنع إنشاء objects فارغة

### 2. كود أكثر أماناً
- كل object مضمون أن يكون مُهيأ بالكامل
- لا توجد قيم افتراضية غير مرغوبة
- أقل عرضة للأخطاء

### 3. وضوح أكبر
- واضح ما الـ parameters المطلوبة
- منطق تهيئة واضح ومنظم
- سهولة القراءة والفهم

## نصائح مهمة

### 1. ترتيب التنفيذ

</div>

```cpp
// الترتيب: Base أولاً، ثم Derived
clsEmployee(...) : clsPerson(...)  // ينفذ أولاً
{
    // ينفذ ثانياً
}
```

<div dir="rtl" style="text-align: right">

### 2. كل الـ Parameters مطلوبة

</div>

```cpp
// يجب إرسال كل الـ parameters
clsEmployee emp1(10, "Mohammed", "Abu-Hadhoud", "email", "phone", 
                "title", "dept", 5000);  // ✓ صحيح

// clsEmployee emp1(10, "Mohammed");  // ✗ خطأ
```

<div dir="rtl" style="text-align: right">

### 3. لا يمكن تجاهل Base Constructor

</div>

```cpp
// إذا لم تستدعي Base Constructor صراحة
// والـ Base Class ليس فيها Default Constructor
// ستحصل على خطأ compilation
```

<div dir="rtl" style="text-align: right">

## مشكلة Print Function

كما رأينا في المثال، الـ `Print()` function تطبع فقط معلومات Person:

**السبب:**
- `Print()` موجودة في Base Class
- لا تعرف شيئاً عن Title, Department, Salary
- تطبع فقط ما تعرفه (Person data)

**الحل المؤقت:**

</div>

```cpp
Employee1.Print();  // Person data
cout << "\n" << Employee1.Title() << endl;      // Employee data
cout << "\n" << Employee1.Department() << endl;
cout << "\n" << Employee1.Salary() << endl;
```

<div dir="rtl" style="text-align: right">

**في الدرس القادم:** سنتعلم **Function Overriding** لحل هذه المشكلة نهائياً!

## مقارنة: قبل وبعد

### قبل (الطريقة الخاطئة):

</div>

```cpp
// Default Constructor مؤقت
clsPerson() { }

// استخدام setter functions
clsEmployee emp1;
emp1.setFirstName("Mohammed");
emp1.setLastName("Abu-Hadhoud");
// ... كثير من الـ setters
```

<div dir="rtl" style="text-align: right">

### بعد (الطريقة الصحيحة):

</div>

```cpp
// Constructor مع parameters للـ base class
clsEmployee emp1(10, "Mohammed", "Abu-Hadhoud", "email", "phone",
                "CEO", "ProgrammingAdvices", 5000);
// Object جاهز فوراً!
```

<div dir="rtl" style="text-align: right">

## كيف يعمل هذا المثال:

1. **إنشاء Object:** تم إنشاء `Employee1` بكل البيانات المطلوبة
2. **تمرير للـ Base:** البيانات الأساسية ذهبت للـ `clsPerson`
3. **Employee Data:** Title, Department, Salary تم تهيئتها في `clsEmployee`
4. **Print:** طبع بيانات Person فقط
5. **Manual Print:** طبع باقي بيانات Employee يدوياً

## الخلاصة

هذا الحل يحل مشكلة الـ Parameterized Constructor في Base Class:

**الفوائد:**
- **أمان:** لا يمكن إنشاء objects فارغة
- **وضوح:** كل المتطلبات واضحة
- **كفاءة:** تهيئة كاملة في خطوة واحدة

**السينتكس:**

</div>

```cpp
DerivedClass(params) : BaseClass(base_params)
{
    // derived class initialization
}
```

<div dir="rtl" style="text-align: right">

**التطبيق:** استخدم هذه الطريقة دائماً عندما تكون Base Class تحتاج parameters

**القادم:** Function Overriding لحل مشكلة Print function!

</div>

<br><br><br><br><br><br><br><br><br>

<a id="english"></a>
[العربية ↗](#arabic)

# Parameterized Constructor of the Base Class

## Review of Previous Lesson

In the previous lesson we learned:
- **Inheritance:** The inheritance principle in OOP
- **Base Class vs Derived Class:** Difference between parent and derived class
- **Constructor Problem:** We faced an issue with Parameterized Constructor

## The Problem We Faced

In the previous lesson, when we wanted to create an object from `clsEmployee`:

```cpp
clsEmployee employee1;  // Error!
```

**Error Message:**
```
The default constructor of clsEmployee cannot be referenced - it's deleted function
```

## Cause of the Problem

**The Issue:** 
- The `clsPerson` (Base Class) has **Parameterized Constructor** only
- No **Default Constructor** exists
- The `clsEmployee` (Derived Class) tries to call Default Constructor of Parent

**Temporary Solution We Used:**
```cpp
// Added Default Constructor temporarily
clsPerson()
{
    // Empty - workaround
}
```

## The Correct Solution

Today we'll learn the correct solution **without Default Constructor**:

### Principle:
- Derived Class calls Base Class Constructor directly
- Passes required parameters to it
- Handles its additional parameters by itself

## Practical Example

```cpp
#include <iostream>
using namespace std;

// Base Class - without Default Constructor
class clsPerson
{
private:
    int _ID;
    string _FirstName;
    string _LastName;
    string _Email;
    string _Phone;

public:
    // Parameterized Constructor only
    clsPerson(int ID, string FirstName, string LastName, string Email, string Phone)
    {
        _ID = ID;
        _FirstName = FirstName;
        _LastName = LastName;
        _Email = Email;
        _Phone = Phone;
    }

    // Read Only Property
    int ID()
    {
        return _ID;
    }

    // Property Set
    void setFirstName(string FirstName)
    {
        _FirstName = FirstName;
    }

    // Property Get
    string FirstName()
    {
        return _FirstName;
    }

    // Property Set
    void setLastName(string LastName)
    {
        _LastName = LastName;
    }

    // Property Get
    string LastName()
    {
        return _LastName;
    }

    // Property Set
    void setEmail(string Email)
    {
        _Email = Email;
    }

    // Property Get
    string Email()
    {
        return _Email;
    }

    // Property Set
    void setPhone(string Phone)
    {
        _Phone = Phone;
    }

    // Property Get
    string Phone()
    {
        return _Phone;
    }

    string FullName()
    {
        return _FirstName + " " + _LastName;
    }

    void Print()
    {
        cout << "\nInfo:";
        cout << "\n___________________";
        cout << "\nID       : " << _ID;
        cout << "\nFirstName: " << _FirstName;
        cout << "\nLastName : " << _LastName;
        cout << "\nFull Name: " << FullName();
        cout << "\nEmail    : " << _Email;
        cout << "\nPhone    : " << _Phone;
        cout << "\n___________________\n";
    }

    void SendEmail(string Subject, string Body)
    {
        cout << "\nThe following message sent successfully to email: " << _Email;
        cout << "\nSubject: " << Subject;
        cout << "\nBody: " << Body << endl;
    }

    void SendSMS(string TextMessage)
    {
        cout << "\nThe following SMS sent successfully to phone: " << _Phone;
        cout << "\n" << TextMessage << endl;
    }
};

// Derived Class with correct Constructor
class clsEmployee : public clsPerson
{
private:
    string _Title;
    string _Department;
    float _Salary;

public:
    // Employee Constructor - The correct solution
    clsEmployee(int ID, string FirstName, string LastName, string Email, string Phone,
               string Title, string Department, float Salary) 
        : clsPerson(ID, FirstName, LastName, Email, Phone)
    {
        // Handle additional Employee properties
        _Title = Title;
        _Department = Department;
        _Salary = Salary;
    }

    // Property Set
    void setTitle(string Title)
    {
        _Title = Title;
    }

    // Property Get
    string Title()
    {
        return _Title;
    }

    // Property Set
    void setDepartment(string Department)
    {
        _Department = Department;
    }

    // Property Get
    string Department()
    {
        return _Department;
    }

    // Property Set
    void setSalary(float Salary)
    {
        _Salary = Salary;
    }

    // Property Get
    float Salary()
    {
        return _Salary;
    }
};

int main()
{
    // Now we can create Employee object correctly
    clsEmployee Employee1(10, "Anas", "Chetoui", "anas@chetoui.com", 
                         "8298982", "CEO", "ProgrammingAdvices", 5000);

    Employee1.Print();
    
    // Print additional properties (temporary solution)
    cout << "\n" << Employee1.Title() << endl;
    cout << "\n" << Employee1.Department() << endl;
    cout << "\n" << Employee1.Salary() << endl;

    return 0;
}
```

## Solution Analysis

### Syntax:
```cpp
clsEmployee(parameters...) : clsPerson(base_parameters)
{
    // Handle derived class properties
}
```

### Explanation:
1. **Constructor Name:** Same as class name (`clsEmployee`)
2. **Parameters:** All required parameters (for base and derived)
3. **Colon (`:`):** Separator for initialization list
4. **Base Constructor Call:** `clsPerson(parameters)`
5. **Body:** Handle derived class properties only

## How It Works?

### Steps:
1. **Receive Parameters:** Constructor receives all parameters
2. **Pass to Base:** Person parameters passed to `clsPerson`
3. **Base Initialization:** `clsPerson` constructor executes
4. **Derived Initialization:** `clsEmployee` code executes

### Detailed Example:

```cpp
// When called
clsEmployee Employee1(10, "Anas", "Chetoui", "anas@chetoui.com", "8298982",
                     "CEO", "ProgrammingAdvices", 5000);

// What happens internally:
// 1. Employee constructor starts
// 2. clsPerson(10, "Anas", "Chetoui", "anas@chetoui.com", "8298982") executes
// 3. Person object initialized completely
// 4. Employee specific code executes:
//    _Title = "CEO"
//    _Department = "ProgrammingAdvices" 
//    _Salary = 5000
// 5. Employee object ready for use
```

## Benefits of This Solution

### 1. No Need for Default Constructor
- Forces sending all required data
- Ensures complete object initialization
- Prevents creating empty objects

### 2. Safer Code
- Every object guaranteed to be fully initialized
- No unwanted default values
- Less prone to errors

### 3. Greater Clarity
- Clear what parameters are required
- Clear and organized initialization logic
- Easy to read and understand

## Important Tips

### 1. Execution Order
```cpp
// Order: Base first, then Derived
clsEmployee(...) : clsPerson(...)  // Executes first
{
    // Executes second
}
```

### 2. All Parameters Required
```cpp
// Must send all parameters
clsEmployee emp1(10, "Mohammed", "Abu-Hadhoud", "email", "phone", 
                "title", "dept", 5000);  // ✓ Correct

// clsEmployee emp1(10, "Mohammed");  // ✗ Error
```

### 3. Cannot Ignore Base Constructor
```cpp
// If you don't explicitly call Base Constructor
// and Base Class doesn't have Default Constructor
// you'll get compilation error
```

## Print Function Problem

As we saw in the example, the `Print()` function prints only Person information:

**Reason:**
- `Print()` exists in Base Class
- Doesn't know anything about Title, Department, Salary
- Prints only what it knows (Person data)

**Temporary Solution:**
```cpp
Employee1.Print();  // Person data
cout << "\n" << Employee1.Title() << endl;      // Employee data
cout << "\n" << Employee1.Department() << endl;
cout << "\n" << Employee1.Salary() << endl;
```

**Next Lesson:** We'll learn **Function Overriding** to solve this problem permanently!

## Comparison: Before and After

### Before (Wrong Way):
```cpp
// Temporary Default Constructor
clsPerson() { }

// Using setter functions
clsEmployee emp1;
emp1.setFirstName("Mohammed");
emp1.setLastName("Abu-Hadhoud");
// ... many setters
```

### After (Correct Way):
```cpp
// Constructor with parameters for base class
clsEmployee emp1(10, "Mohammed", "Abu-Hadhoud", "email", "phone",
                "CEO", "ProgrammingAdvices", 5000);
// Object ready immediately!
```

## How This Example Works:

1. **Object Creation:** `Employee1` created with all required data
2. **Pass to Base:** Basic data went to `clsPerson`
3. **Employee Data:** Title, Department, Salary initialized in `clsEmployee`
4. **Print:** Printed Person data only
5. **Manual Print:** Manually printed remaining Employee data

## Summary

This solution solves the Parameterized Constructor problem in Base Class:

**Benefits:**
- **Safety:** Cannot create empty objects
- **Clarity:** All requirements are clear
- **Efficiency:** Complete initialization in one step

**Syntax:**
```cpp
DerivedClass(params) : BaseClass(base_params)
{
    // derived class initialization
}
```

**Application:** Always use this approach when Base Class needs parameters

**Next:** Function Overriding to solve Print function problem!
<br><br><br><br>

---
*Anas Chetoui - `anaschetoui`*
