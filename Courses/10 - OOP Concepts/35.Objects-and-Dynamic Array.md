<a id="arabic"></a>
[English ↙](#english)

<div dir="rtl" style="text-align: right;">

# الكائنات والـ Dynamic Array

## المفهوم الأساسي

**Dynamic Array = مصفوفة بحجم متغير يتم تحديده وقت التشغيل**

بدلاً من:
```cpp
clsA objects[5];  // حجم ثابت
```

**نستخدم:**
```cpp
clsA * objects = new clsA[size];  // حجم ديناميكي
```

### الفرق الجوهري:
- **Static Array:** الحجم محدد وقت الكتابة
- **Dynamic Array:** الحجم محدد وقت التشغيل

## إعلان Dynamic Array للكائنات

### الصيغة الأساسية:

</div>

```cpp
ClassName * arrayName = new ClassName[arraySize];
```

<div dir="rtl" style="text-align: right;">

### مثال عملي:

</div>

```cpp
int size = 10;  // يمكن أن تكون قيمة من المستخدم
clsA * arrA = new clsA[size];  // dynamic allocation
```

<div dir="rtl" style="text-align: right;">

## متطلبات الـ Class: Default Constructor

**مشكلة مهمة:** Dynamic Arrays تتطلب Default Constructor!

### الـ Class الصحيحة:

</div>

```cpp
class clsA
{
public:
    int x;

    // Default Constructor - ضروري للـ Dynamic Arrays!
    clsA() {}

    // Parameterized Constructor
    clsA(int value)
    {
        x = value;
    }

    void Print()
    {
        cout << "The value of x=" << x << endl;
    }
};
```

<div dir="rtl" style="text-align: right;">

### لماذا Default Constructor ضروري؟

عند كتابة `new clsA[5]`، الـ Compiler:
1. ينشئ 5 objects
2. يستدعي Default Constructor لكل object
3. **بدون Default Constructor = خطأ في الترجمة!**

## إنشاء وتهيئة Dynamic Array

### الخطوة 1: التخصيص (Allocation)

</div>

```cpp
short NumberOfObjects = 5;
clsA * arrA = new clsA[NumberOfObjects];
```

<div dir="rtl" style="text-align: right;">

### الخطوة 2: التهيئة (Initialization)

</div>

```cpp
// استدعاء constructor لكل عنصر في المصفوفة
for (int i = 0; i < NumberOfObjects; i++) 
{
    arrA[i] = clsA(i);  // تهيئة بقيمة i
}
```

<div dir="rtl" style="text-align: right;">

### الخطوة 3: الاستخدام

</div>

```cpp
// طباعة محتويات المصفوفة
for (int i = 0; i < NumberOfObjects; i++) 
{
    arrA[i].Print();
}
```

<div dir="rtl" style="text-align: right;">

## المثال الكامل العملي

</div>

```cpp
#include<iostream>
using namespace std;

class clsA
{
public:
    int x;

    // Default constructor - ضروري!
    clsA() {}

    // Parameterized Constructor
    clsA(int value)
    {
        x = value;
    }

    void Print()
    {
        cout << "The value of x=" << x << endl;
    }
};

int main() 
{
    short NumberOfObjects = 5;

    // تخصيص dynamic array بحجم NumberOfObjects
    clsA * arrA = new clsA[NumberOfObjects];

    // استدعاء constructor لكل index في المصفوفة
    for (int i = 0; i < NumberOfObjects; i++) 
    {
        arrA[i] = clsA(i);
    }

    // طباعة محتويات المصفوفة
    for (int i = 0; i < NumberOfObjects; i++) 
    {
        arrA[i].Print();
    }

    // تحرير الذاكرة (مهم!)
    delete[] arrA;

    return 0;
}
```

<div dir="rtl" style="text-align: right;">

## النتيجة المتوقعة:

</div>

```
The value of x=0
The value of x=1
The value of x=2
The value of x=3
The value of x=4
```

<div dir="rtl" style="text-align: right;">

## إدارة الذاكرة: مسؤوليتك!

### القاعدة الذهبية:
**كل `new` يجب أن يقابله `delete`!**

### للـ Dynamic Arrays:

</div>

```cpp
// تخصيص
clsA * arrA = new clsA[size];

// الاستخدام
// ...

// تحرير - استخدم delete[] وليس delete
delete[] arrA;
```

<div dir="rtl" style="text-align: right;">

### خطأ شائع:

</div>

```cpp
delete arrA;    // ❌ خطأ - delete عادي
delete[] arrA;  // ✅ صحيح - delete للمصفوفات
```

<div dir="rtl" style="text-align: right;">

## مقارنة: Dynamic Array vs Vector

| الخاصية | Dynamic Array | Vector |
|---------|---------------|---------|
| **إدارة الذاكرة** | يدوية (`delete[]`) | تلقائية |
| **متطلبات Constructor** | Default + Parameterized | Parameterized فقط |
| **تغيير الحجم** | غير ممكن | ممكن (`push_back`) |
| **الأمان** | عرضة لـ Memory Leaks | آمن |
| **الأداء** | أسرع قليلاً | ممتاز |
| **سهولة الاستخدام** | معقد | بسيط |

## الوصول للعناصر

### طرق الوصول:

</div>

```cpp
// الطريقة الأولى: استخدام []
arrA[0].Print();
arrA[i].x = 100;

// الطريقة الثانية: استخدام pointer arithmetic
(arrA + i)->Print();
(*(arrA + i)).x = 100;
```

<div dir="rtl" style="text-align: right;">

## أخطاء شائعة وحلولها

### 1. نسيان Default Constructor:

</div>

```cpp
class clsA
{
public:
    clsA(int value) { x = value; }  // فقط parameterized
    // ❌ خطأ: لا يوجد default constructor
};

clsA * arr = new clsA[5];  // خطأ في الترجمة!
```

<div dir="rtl" style="text-align: right;">

**الحل:**

</div>

```cpp
class clsA
{
public:
    clsA() {}  // ✅ إضافة default constructor
    clsA(int value) { x = value; }
};
```

<div dir="rtl" style="text-align: right;">

### 2. نسيان تحرير الذاكرة:

</div>

```cpp
void someFunction()
{
    clsA * arr = new clsA[100];
    // استخدام المصفوفة
    // ❌ نسيان delete[] arr;
}  // Memory leak!
```

<div dir="rtl" style="text-align: right;">

### 3. استخدام delete بدلاً من delete[]:

</div>

```cpp
clsA * arr = new clsA[5];
delete arr;    // ❌ خطأ - سلوك غير محدد
delete[] arr;  // ✅ صحيح
```

<div dir="rtl" style="text-align: right;">

## متى تستخدم Dynamic Arrays؟

### استخدم Dynamic Array عندما:
- **تحتاج تحكم دقيق في الذاكرة**
- **تعمل مع أنظمة محدودة الموارد**
- **الحجم معروف ولا يتغير**
- **الأداء أولوية قصوى**

### استخدم Vector عندما:
- **سهولة الاستخدام مهمة**
- **الحجم قد يتغير أثناء التشغيل**
- **تريد أمان إضافي**
- **مشروع كبير ومعقد**

## الخلاصة

### النقاط الأساسية:
1. **`ClassName * arr = new ClassName[size]`** للتخصيص الديناميكي
2. **Default Constructor ضروري** مع Parameterized Constructor
3. **`delete[] arr`** لتحرير الذاكرة - مسؤوليتك!
4. **تهيئة بعد التخصيص:** `arr[i] = ClassName(params)`

### متى تستخدم:
- **تحكم دقيق في الذاكرة**
- **أنظمة محدودة الموارد**
- **حجم ثابت معروف مسبقاً**

**تذكر:** **مع القوة تأتي المسؤولية - إدارة الذاكرة مسؤوليتك!**

</div>

<br><br><br><br><br><br><br><br><br>

<a id="english"></a>
[العربية ↗](#arabic)

# Objects and Dynamic Array

## Basic Concept

**Dynamic Array = array with variable size determined at runtime**

Instead of:
```cpp
clsA objects[5];  // fixed size
```

**We use:**
```cpp
clsA * objects = new clsA[size];  // dynamic size
```

### Core Difference:
- **Static Array:** size determined at compile time
- **Dynamic Array:** size determined at runtime

## Declaring Dynamic Array for Objects

### Basic Syntax:

```cpp
ClassName * arrayName = new ClassName[arraySize];
```

### Practical Example:

```cpp
int size = 10;  // can be user input
clsA * arrA = new clsA[size];  // dynamic allocation
```

## Class Requirements: Default Constructor

**Important Issue:** Dynamic Arrays require Default Constructor!

### Correct Class:

```cpp
class clsA
{
public:
    int x;

    // Default Constructor - required for Dynamic Arrays!
    clsA() {}

    // Parameterized Constructor
    clsA(int value)
    {
        x = value;
    }

    void Print()
    {
        cout << "The value of x=" << x << endl;
    }
};
```

### Why is Default Constructor Required?

When writing `new clsA[5]`, the Compiler:
1. Creates 5 objects
2. Calls Default Constructor for each object
3. **Without Default Constructor = compilation error!**

## Creating and Initializing Dynamic Array

### Step 1: Allocation

```cpp
short NumberOfObjects = 5;
clsA * arrA = new clsA[NumberOfObjects];
```

### Step 2: Initialization

```cpp
// calling constructor for each index of array
for (int i = 0; i < NumberOfObjects; i++) 
{
    arrA[i] = clsA(i);  // initialize with value i
}
```

### Step 3: Usage

```cpp
// printing contents of array
for (int i = 0; i < NumberOfObjects; i++) 
{
    arrA[i].Print();
}
```

## Complete Practical Example

```cpp
#include<iostream>
using namespace std;

class clsA
{
public:
    int x;

    // Default constructor - required!
    clsA() {}

    // Parameterized Constructor
    clsA(int value)
    {
        x = value;
    }

    void Print()
    {
        cout << "The value of x=" << x << endl;
    }
};

int main() 
{
    short NumberOfObjects = 5;

    // allocating dynamic array of Size NumberOfObjects
    clsA * arrA = new clsA[NumberOfObjects];

    // calling constructor for each index of array
    for (int i = 0; i < NumberOfObjects; i++) 
    {
        arrA[i] = clsA(i);
    }

    // printing contents of array
    for (int i = 0; i < NumberOfObjects; i++) 
    {
        arrA[i].Print();
    }

    // free memory (important!)
    delete[] arrA;

    return 0;
}
```

## Expected Output:

```
The value of x=0
The value of x=1
The value of x=2
The value of x=3
The value of x=4
```

## Memory Management: Your Responsibility!

### Golden Rule:
**Every `new` must be matched with `delete`!**

### For Dynamic Arrays:

```cpp
// allocation
clsA * arrA = new clsA[size];

// usage
// ...

// deallocation - use delete[] not delete
delete[] arrA;
```

### Common Mistake:

```cpp
delete arrA;    // ❌ wrong - regular delete
delete[] arrA;  // ✅ correct - delete for arrays
```

## Comparison: Dynamic Array vs Vector

| Feature | Dynamic Array | Vector |
|---------|---------------|---------|
| **Memory Management** | Manual (`delete[]`) | Automatic |
| **Constructor Requirements** | Default + Parameterized | Parameterized only |
| **Resize** | Not possible | Possible (`push_back`) |
| **Safety** | Prone to Memory Leaks | Safe |
| **Performance** | Slightly faster | Excellent |
| **Ease of Use** | Complex | Simple |

## Accessing Elements

### Access Methods:

```cpp
// Method 1: using []
arrA[0].Print();
arrA[i].x = 100;

// Method 2: using pointer arithmetic
(arrA + i)->Print();
(*(arrA + i)).x = 100;
```

## Common Errors and Solutions

### 1. Forgetting Default Constructor:

```cpp
class clsA
{
public:
    clsA(int value) { x = value; }  // only parameterized
    // ❌ Error: no default constructor
};

clsA * arr = new clsA[5];  // compilation error!
```

**Solution:**

```cpp
class clsA
{
public:
    clsA() {}  // ✅ add default constructor
    clsA(int value) { x = value; }
};
```

### 2. Forgetting Memory Deallocation:

```cpp
void someFunction()
{
    clsA * arr = new clsA[100];
    // use array
    // ❌ forgetting delete[] arr;
}  // Memory leak!
```

### 3. Using delete instead of delete[]:

```cpp
clsA * arr = new clsA[5];
delete arr;    // ❌ wrong - undefined behavior
delete[] arr;  // ✅ correct
```

## When to Use Dynamic Arrays?

### Use Dynamic Array when:
- **Need precise memory control**
- **Working with resource-constrained systems**
- **Size is known and doesn't change**
- **Performance is top priority**

### Use Vector when:
- **Ease of use is important**
- **Size may change during runtime**
- **Want additional safety**
- **Large and complex project**

## Summary

### Key Points:
1. **`ClassName * arr = new ClassName[size]`** for dynamic allocation
2. **Default Constructor required** with Parameterized Constructor
3. **`delete[] arr`** to free memory - your responsibility!
4. **Initialize after allocation:** `arr[i] = ClassName(params)`

### When to Use:
- **Precise memory control**
- **Resource-constrained systems**
- **Fixed size known beforehand**

**Remember:** **With great power comes great responsibility - memory management is yours!**

<br><br><br>
---
*Anas Chetoui - `anaschetoui`*
