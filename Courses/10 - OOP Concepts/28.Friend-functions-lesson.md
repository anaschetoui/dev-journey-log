<a id="arabic"></a>
[English ↙](#english)

<div dir="rtl" style="text-align: right">

# الدوال الصديقة (Friend Functions)

## مراجعة الدرس السابق: الفئات الصديقة

في الدرس السابق تعلمنا عن **Friend Classes** حيث:
- **clsB صادقت clsA** ودفعت لها رشوة
- **clsA كتبت لها بطاقة دخول** عن طريق `friend class clsB`
- **clsB حصلت على وصول كامل** لكل شيء في clsA: private, protected, public
- **الرشوة كانت على مستوى الفئة كاملة**

## درس اليوم: الرشوة المصغرة!

اليوم سنأخذ مفهوم الصداقة على **مستوى الدالة وليس على مستوى الفئة كاملة**. هذه **رشوة مصغرة** - فقط على مستوى دالة واحدة!

### الفرق بين الرشوتين:
- **Friend Class:** رشوة شاملة - الفئة كاملة تحصل على الوصول
- **Friend Function:** رشوة مصغرة - دالة واحدة فقط تحصل على الوصول

## الكود الأساسي: نفس clsA من الدرس السابق

</div>

```cpp
class clsA
{
private:
    int _Var1;        // متغير خاص = 10

protected:
    int _Var3;        // متغير محمي = 30

public:
    int Var2;         // متغير عام = 20
    
    clsA()
    {
        _Var1 = 10;   // تهيئة المتغير الخاص
        Var2 = 20;    // تهيئة المتغير العام
        _Var3 = 30;   // تهيئة المتغير المحمي
    }
};
```

<div dir="rtl" style="text-align: right">

### الوضع الطبيعي: الوصول المحدود

عند إنشاء Object من clsA:

</div>

```cpp
clsA A1;
// A1. سيُظهر فقط Var2 (20)
// A1._Var1 و A1._Var3 غير مرئيين ومحظور الوصول إليهما
```

<div dir="rtl" style="text-align: right">

## المحاولة الأولى: دالة عادية في الشارع

الآن نريد إنشاء **دالة في الشارع** (خارج الفئة) لحساب مجموع المتغيرات الثلاثة:

</div>

```cpp
// دالة عادية في الشارع - خارج أي فئة
int MySum(clsA A1)
{
    // محاولة الوصول للمتغيرات
    return A1._Var1 + A1.Var2 + A1._Var3;  // ❌ خطأ!
}
```

<div dir="rtl" style="text-align: right">

### المشكلة:
- **A1.Var2** ✅ يعمل - لأنه Public
- **A1._Var1** ❌ لا يعمل - لأنه Private
- **A1._Var3** ❌ لا يعمل - لأنه Protected

**النتيجة:** compilation error لأن الدالة لا تستطيع الوصول للـ Private والـ Protected Members.

## الحل: دفع رشوة مصغرة!

### الخطوة الأولى: الدالة تذهب لـ clsA وتطلب رشوة

الدالة `MySum` تقول لـ `clsA`: "أريد أن أدفع لك رشوة مصغرة حتى تسمحي لي بالوصول إلى كل متغيراتك!"

### الخطوة الثانية: clsA تقبل الرشوة وتعطي بطاقة دخول

</div>

```cpp
class clsA
{
private:
    int _Var1;

protected:
    int _Var3;

public:
    int Var2;
    
    clsA()
    {
        _Var1 = 10;
        Var2 = 20;
        _Var3 = 30;
    }
   
    // هنا دفعت الرشوة المصغرة! 💰
    friend int MySum(clsA A1);    // Friend Function declaration
};
```

<div dir="rtl" style="text-align: right">

### ماذا حدث؟

1. **clsA عرّفت:** `friend int MySum(clsA A1);`
2. **هذا يعني:** "إذا جاءكم صديق اسمه MySum فأعطوه كل Private والProtected والPublic Members"
3. **الرشوة المصغرة:** فقط هذه الدالة تحصل على امتياز، وليس فئة كاملة

## النتيجة: الوصول الكامل بعد الرشوة المصغرة

</div>

```cpp
// الآن الدالة خارج الفئة لكن لها امتيازات خاصة!
int MySum(clsA A1)
{
    // السحر! 🎭 يمكن الوصول لكل شيء رغم أن الدالة خارج الفئة
    return A1._Var1 + A1.Var2 + A1._Var3;  // ✅ 10 + 20 + 30 = 60
}
```

<div dir="rtl" style="text-align: right">

### الرسم التوضيحي: Friend Function

</div>

```
قبل الرشوة المصغرة:
┌─────────────────────────────────────────────────────┐
│           الدالة في الشارع (MySum)                │
├─────────────────────────────────────────────────────┤
│                    ⬇ محاولة الوصول                │
│                                                     │
│ 🔒 A1._Var1   ← ممنوع الوصول                      │
│ 🔓 A1.Var2    ← مسموح الوصول                      │  
│ 🔒 A1._Var3   ← ممنوع الوصول                      │
│                                                     │
│             ❌ Compilation Error                    │
└─────────────────────────────────────────────────────┘

بعد الرشوة المصغرة (friend function):
┌─────────────────────────────────────────────────────┐
│      الدالة الصديقة في الشارع (MySum)            │
├─────────────────────────────────────────────────────┤
│                    ⬇ وصول مميز                     │
│                                                     │
│ 💰 A1._Var1   ← مسموح الوصول (رشوة مصغرة)        │
│ 🔓 A1.Var2    ← مسموح الوصول (عام للجميع)         │  
│ 💰 A1._Var3   ← مسموح الوصول (رشوة مصغرة)        │
│                                                     │
│          ✅ Return: 10 + 20 + 30 = 60             │
└─────────────────────────────────────────────────────┘
```

<div dir="rtl" style="text-align: right">

## نقطة مهمة جداً: Friend Function ليست عضو!

### الفرق الجوهري:

</div>

```cpp
clsA A1;

// ❌ هذا لا يعمل - لأن MySum ليست عضو في الفئة
// A1.MySum();  

// ✅ هذا يعمل - لأن MySum دالة عادية في الشارع
MySum(A1);
```

<div dir="rtl" style="text-align: right">

**تذكر:** Friend Function هي:
- **دالة خارجية** (في الشارع)
- **ليست عضو** في الفئة
- **لكن لها امتيازات خاصة** للوصول
- **تستدعى مثل أي دالة عادية** وليس عبر النقطة

## مثال على دالة بدون رشوة: Fun2

لنرى ماذا يحدث مع دالة لم تدفع رشوة:

</div>

```cpp
// دالة مسكينة لم تدفع رشوة!
int Fun2(clsA A1)
{
    return A1._Var1 + A1.Var2 + A1._Var3;  // ❌ Compilation Error
}
```

<div dir="rtl" style="text-align: right">

**رسالة الخطأ:**
```
Error: '_Var1' is a private member of 'clsA'
Error: '_Var3' is a protected member of 'clsA'
```

**الشرح:** Fun2 مسكينة لأنها لم تدفع رشوة ولم تُعرّف كصديقة، فتواجه اعتراض من المترجم!

### لو أردنا إصلاح Fun2:

</div>

```cpp
class clsA
{
    // نفس المحتويات...
    
    friend int MySum(clsA A1);     // دفعت رشوة ✅
    friend int Fun2(clsA A1);      // دفعت رشوة أيضاً ✅
};
```

<div dir="rtl" style="text-align: right">

الآن Fun2 ستعمل بنفس طريقة MySum!

## الكود الكامل مع التوضيحات

</div>

```cpp
#include<iostream>
using namespace std;

class clsA
{
private:
    int _Var1;        // متغير خاص

protected:
    int _Var3;        // متغير محمي

public:
    int Var2;         // متغير عام
    
    clsA()
    {
        _Var1 = 10;   // قيمة المتغير الخاص
        Var2 = 20;    // قيمة المتغير العام
        _Var3 = 30;   // قيمة المتغير المحمي
    }
   
    // بطاقة دخول للدالة الصديقة! 🎫
    friend int MySum(clsA A1);    // Friend Function declaration
};

// دالة عادية في الشارع - لكن لها امتيازات خاصة!
int MySum(clsA A1)
{
    // السحر! يمكن الوصول لكل شيء رغم أن الدالة خارج الفئة
    return A1._Var1 + A1.Var2 + A1._Var3;  // 10 + 20 + 30 = 60
}

// دالة مسكينة بدون رشوة (معلقة لتجنب الخطأ)
//int Fun2(clsA A1)
//{
//    return A1._Var1 + A1.Var2 + A1._Var3;  // ❌ خطأ!
//}

int main()
{
    clsA A1;          // إنشاء كائن من clsA
   
    cout << "Sum = " << MySum(A1) << endl;  // النتيجة: Sum = 60
    
    // تذكر: لا يمكن استدعاؤها هكذا
    // A1.MySum();  // ❌ خطأ - ليست عضو في الفئة
    
    system("pause>0");
    return 0;
}
```

<div dir="rtl" style="text-align: right">

## خصائص Friend Functions

### 1. المرونة الكاملة

Friend Functions مثل أي دالة C++ عادية:

</div>

```cpp
// يمكن أن ترجع أي نوع
friend void PrintInfo(clsA A1);           // void
friend int MySum(clsA A1);                // integer  
friend bool IsValid(clsA A1);             // boolean
friend string GetDescription(clsA A1);     // string

// يمكن أن تأخذ أي معاملات
friend int Calculate(clsA A1, int x);              // معامل إضافي
friend void Process(clsA A1, clsA A2);             // كائنان
friend double Average(clsA A1, double factor);     // أنواع مختلفة
```

<div dir="rtl" style="text-align: right">

### 2. إمكانية Overloading

</div>

```cpp
class clsA
{
    // يمكن عمل overloading للدوال الصديقة
    friend int Process(clsA A1);           // دالة واحدة
    friend int Process(clsA A1, int x);    // دالة بمعامل إضافي
    friend void Process(clsA A1, string s); // دالة بنوع مختلف
};
```

<div dir="rtl" style="text-align: right">

### 3. موقع التعريف

يمكن تعريف Friend Function في أي مكان:

</div>

```cpp
// في نفس الملف
int MySum(clsA A1) { /* ... */ }

// في ملف آخر
// في فئة أخرى (كعضو في فئة أخرى)
class clsB
{
public:
    int MySum(clsA A1) { /* نفس الوظيفة */ }
};
```

<div dir="rtl" style="text-align: right">

## مقارنة Friend Function مع Friend Class

### الجدول المقارن:

| الخاصية | Friend Function | Friend Class |
|---------|----------------|--------------|
| **مستوى الوصول** | دالة واحدة فقط | الفئة كاملة |
| **التحكم** | دقيق ومحدود | شامل |
| **الأمان** | أكثر أماناً | أقل أماناً |
| **الاستخدام** | حالات محددة | تعاون شامل |
| **التعقيد** | بسيط | معقد أكثر |

### متى نستخدم كلاً منهما؟

**Friend Function - الرشوة المصغرة:**
- عندما نحتاج **دالة واحدة فقط** للوصول
- للعمليات الحسابية البسيطة
- لدوال المساعدة (Helper Functions)
- عندما نريد **تحكم دقيق** في الوصول

**Friend Class - الرشوة الشاملة:**
- عندما نحتاج **تعاون وثيق** بين فئتين
- للأنظمة المتكاملة
- عندما الفئة تحتاج **وصول مستمر** لفئة أخرى

## أمثلة عملية لاستخدام Friend Functions

### 1. دوال المقارنة

</div>

```cpp
class clsStudent
{
private:
    float _grade;
    
public:
    clsStudent(float grade) { _grade = grade; }
    
    // دالة صديقة للمقارنة
    friend bool IsEqual(clsStudent s1, clsStudent s2);
};

bool IsEqual(clsStudent s1, clsStudent s2)
{
    return s1._grade == s2._grade;  // وصول مباشر للدرجات الخاصة
}
```

<div dir="rtl" style="text-align: right">

### 2. دوال الإدخال والإخراج

</div>

```cpp
class clsPerson
{
private:
    string _name;
    int _age;
    
public:
    // دوال صديقة للإدخال والإخراج
    friend ostream& operator<<(ostream& out, clsPerson p);
    friend istream& operator>>(istream& in, clsPerson& p);
};

ostream& operator<<(ostream& out, clsPerson p)
{
    out << "Name: " << p._name << ", Age: " << p._age;
    return out;
}
```

<div dir="rtl" style="text-align: right">

### 3. دوال الحسابات المعقدة

</div>

```cpp
class clsVector
{
private:
    double _x, _y;
    
public:
    clsVector(double x, double y) : _x(x), _y(y) {}
    
    // دالة صديقة لحساب المسافة
    friend double Distance(clsVector v1, clsVector v2);
};

double Distance(clsVector v1, clsVector v2)
{
    double dx = v1._x - v2._x;
    double dy = v1._y - v2._y;
    return sqrt(dx*dx + dy*dy);
}
```

<div dir="rtl" style="text-align: right">

## التحذيرات والاعتبارات

### مخاطر الأمان:
- **كسر التغليف:** تدمير مبدأ Encapsulation جزئياً
- **الاعتمادية:** إنشاء علاقة اعتماد بين الدالة والفئة
- **صعوبة التتبع:** صعوبة معرفة من يصل إلى البيانات الخاصة

### نصائح للاستخدام الآمن:
1. **استخدمها بحذر:** فقط عند الضرورة
2. **دوّق السبب:** اشرح لماذا تحتاج Friend Function
3. **قلل العدد:** لا تكثر من Friend Functions
4. **فكر في البدائل:** هل يمكن استخدام Getter/Setter بدلاً من ذلك؟

## الخلاصة النهائية

### ما هي Friend Functions؟
**دوال خارجية (في الشارع) لها امتيازات خاصة للوصول إلى جميع أعضاء فئة معينة.**

### الفكرة الأساسية:
- **دالة خارجية:** ليست عضو في أي فئة
- **امتيازات خاصة:** يمكنها الوصول لـ private, protected, public
- **رشوة مصغرة:** تحكم دقيق في مستوى الوصول
- **استدعاء عادي:** تستدعى مثل أي دالة عادية

### الفروق المهمة:
- **Friend Function ≠ Member Function:** ليست عضو في الفئة
- **Friend Function ≠ Normal Function:** لها امتيازات خاصة
- **Friend Function = Targeted Access:** وصول محدد ودقيق

### التذكير المهم:
Friend Functions **تكسر مبدأ Encapsulation جزئياً** لكنها توفر **تحكم أدق** من Friend Classes. استخدمها **بحكمة ولأغراض محددة**!

</div>

<br><br><br><br><br><br><br><br><br>

<a id="english"></a>
[العربية ↗](#arabic)

# Friend Functions

## Review of Previous Lesson: Friend Classes

In the previous lesson, we learned about **Friend Classes** where:
- **clsB befriended clsA** and paid it a bribe
- **clsA wrote it an access card** via `friend class clsB`
- **clsB gained complete access** to everything in clsA: private, protected, public
- **The bribe was at the entire class level**

## Today's Lesson: Miniature Bribery!

Today we'll take the friendship concept at the **function level rather than the entire class level**. This is **miniature bribery** - only at the level of a single function!

### The Difference Between the Two Bribes:
- **Friend Class:** Comprehensive bribery - the entire class gets access
- **Friend Function:** Miniature bribery - only one function gets access

## Basic Code: Same clsA from Previous Lesson

```cpp
class clsA
{
private:
    int _Var1;        // Private variable = 10

protected:
    int _Var3;        // Protected variable = 30

public:
    int Var2;         // Public variable = 20
    
    clsA()
    {
        _Var1 = 10;   // Initialize private variable
        Var2 = 20;    // Initialize public variable
        _Var3 = 30;   // Initialize protected variable
    }
};
```

### Normal Situation: Limited Access

When creating an Object from clsA:

```cpp
clsA A1;
// A1. will only show Var2 (20)
// A1._Var1 and A1._Var3 are invisible and access is prohibited
```

## First Attempt: Regular Function in the Street

Now we want to create a **function in the street** (outside the class) to calculate the sum of the three variables:

```cpp
// Regular function in the street - outside any class
int MySum(clsA A1)
{
    // Attempting to access variables
    return A1._Var1 + A1.Var2 + A1._Var3;  // ❌ Error!
}
```

### The Problem:
- **A1.Var2** ✅ Works - because it's Public
- **A1._Var1** ❌ Doesn't work - because it's Private
- **A1._Var3** ❌ Doesn't work - because it's Protected

**Result:** Compilation error because the function cannot access Private and Protected Members.

## Solution: Pay Miniature Bribery!

### Step One: Function goes to clsA and requests bribery

The `MySum` function says to `clsA`: "I want to pay you a miniature bribe so you allow me to access all your variables!"

### Step Two: clsA accepts the bribe and gives access card

```cpp
class clsA
{
private:
    int _Var1;

protected:
    int _Var3;

public:
    int Var2;
    
    clsA()
    {
        _Var1 = 10;
        Var2 = 20;
        _Var3 = 30;
    }
   
    // Here the miniature bribe was paid! 💰
    friend int MySum(clsA A1);    // Friend Function declaration
};
```

### What happened?

1. **clsA declared:** `friend int MySum(clsA A1);`
2. **This means:** "If a friend named MySum comes to you, give him all Private, Protected, and Public Members"
3. **Miniature bribery:** Only this function gets privilege, not an entire class

## Result: Full Access After Miniature Bribery

```cpp
// Now the function is outside the class but has special privileges!
int MySum(clsA A1)
{
    // Magic! 🎭 Can access everything despite the function being outside the class
    return A1._Var1 + A1.Var2 + A1._Var3;  // ✅ 10 + 20 + 30 = 60
}
```

### Visual Diagram: Friend Function

```
Before Miniature Bribery:
┌─────────────────────────────────────────────────────┐
│           Function in the Street (MySum)            │
├─────────────────────────────────────────────────────┤
│                    ⬇ Access attempt                │
│                                                     │
│ 🔒 A1._Var1   ← Access denied                      │
│ 🔓 A1.Var2    ← Access allowed                     │  
│ 🔒 A1._Var3   ← Access denied                      │
│                                                     │
│             ❌ Compilation Error                    │
└─────────────────────────────────────────────────────┘

After Miniature Bribery (friend function):
┌─────────────────────────────────────────────────────┐
│      Friend Function in the Street (MySum)         │
├─────────────────────────────────────────────────────┤
│                    ⬇ Special access                │
│                                                     │
│ 💰 A1._Var1   ← Access allowed (miniature bribe)   │
│ 🔓 A1.Var2    ← Access allowed (public for all)    │  
│ 💰 A1._Var3   ← Access allowed (miniature bribe)   │
│                                                     │
│          ✅ Return: 10 + 20 + 30 = 60             │
└─────────────────────────────────────────────────────┘
```

## Very Important Point: Friend Function is NOT a Member!

### The Essential Difference:

```cpp
clsA A1;

// ❌ This doesn't work - because MySum is not a member of the class
// A1.MySum();  

// ✅ This works - because MySum is a regular function in the street
MySum(A1);
```

**Remember:** Friend Function is:
- **External function** (in the street)
- **Not a member** of the class
- **But has special privileges** for access
- **Called like any regular function** and not via dot operator

## Example of Function Without Bribery: Fun2

Let's see what happens with a function that didn't pay a bribe:

```cpp
// Poor function that didn't pay a bribe!
int Fun2(clsA A1)
{
    return A1._Var1 + A1.Var2 + A1._Var3;  // ❌ Compilation Error
}
```

**Error Message:**
```
Error: '_Var1' is a private member of 'clsA'
Error: '_Var3' is a protected member of 'clsA'
```

**Explanation:** Fun2 is unfortunate because it didn't pay a bribe and wasn't defined as a friend, so it faces objection from the compiler!

### If we wanted to fix Fun2:

```cpp
class clsA
{
    // Same contents...
    
    friend int MySum(clsA A1);     // Paid bribe ✅
    friend int Fun2(clsA A1);      // Also paid bribe ✅
};
```

Now Fun2 will work the same way as MySum!

## Complete Code with Explanations

```cpp
#include<iostream>
using namespace std;

class clsA
{
private:
    int _Var1;        // Private variable

protected:
    int _Var3;        // Protected variable

public:
    int Var2;         // Public variable
    
    clsA()
    {
        _Var1 = 10;   // Private variable value
        Var2 = 20;    // Public variable value
        _Var3 = 30;   // Protected variable value
    }
   
    // Access card for the friend function! 🎫
    friend int MySum(clsA A1);    // Friend Function declaration
};

// Regular function in the street - but with special privileges!
int MySum(clsA A1)
{
    // Magic! Can access everything despite the function being outside the class
    return A1._Var1 + A1.Var2 + A1._Var3;  // 10 + 20 + 30 = 60
}

// Poor function without bribery (commented to avoid error)
//int Fun2(clsA A1)
//{
//    return A1._Var1 + A1.Var2 + A1._Var3;  // ❌ Error!
//}

int main()
{
    clsA A1;          // Create object from clsA
   
    cout << "Sum = " << MySum(A1) << endl;  // Result: Sum = 60
    
    // Remember: Cannot be called like this
    // A1.MySum();  // ❌ Error - not a member of the class
    
    system("pause>0");
    return 0;
}
```

## Friend Functions Characteristics

### 1. Complete Flexibility

Friend Functions are like any regular C++ function:

```cpp
// Can return any type
friend void PrintInfo(clsA A1);           // void
friend int MySum(clsA A1);                // integer  
friend bool IsValid(clsA A1);             // boolean
friend string GetDescription(clsA A1);     // string

// Can take any parameters
friend int Calculate(clsA A1, int x);              // Additional parameter
friend void Process(clsA A1, clsA A2);             // Two objects
friend double Average(clsA A1, double factor);     // Different types
```

### 2. Overloading Capability

```cpp
class clsA
{
    // Friend functions can be overloaded
    friend int Process(clsA A1);           // One function
    friend int Process(clsA A1, int x);    // Function with additional parameter
    friend void Process(clsA A1, string s); // Function with different type
};
```

### 3. Definition Location

Friend Function can be defined anywhere:

```cpp
// In the same file
int MySum(clsA A1) { /* ... */ }

// In another file
// In another class (as a member of another class)
class clsB
{
public:
    int MySum(clsA A1) { /* same functionality */ }
};
```

## Comparison Friend Function vs Friend Class

### Comparison Table:

| Property | Friend Function | Friend Class |
|----------|----------------|--------------|
| **Access Level** | Single function only | Entire class |
| **Control** | Precise and limited | Comprehensive |
| **Security** | More secure | Less secure |
| **Usage** | Specific cases | Comprehensive cooperation |
| **Complexity** | Simple | More complex |

### When to use each?

**Friend Function - Miniature Bribery:**
- When we need **only one function** for access
- For simple mathematical operations
- For helper functions
- When we want **precise control** over access

**Friend Class - Comprehensive Bribery:**
- When we need **close cooperation** between two classes
- For integrated systems
- When a class needs **continuous access** to another class

## Practical Examples of Friend Functions Usage

### 1. Comparison Functions

```cpp
class clsStudent
{
private:
    float _grade;
    
public:
    clsStudent(float grade) { _grade = grade; }
    
    // Friend function for comparison
    friend bool IsEqual(clsStudent s1, clsStudent s2);
};

bool IsEqual(clsStudent s1, clsStudent s2)
{
    return s1._grade == s2._grade;  // Direct access to private grades
}
```

### 2. Input/Output Functions

```cpp
class clsPerson
{
private:
    string _name;
    int _age;
    
public:
    // Friend functions for input/output
    friend ostream& operator<<(ostream& out, clsPerson p);
    friend istream& operator>>(istream& in, clsPerson& p);
};

ostream& operator<<(ostream& out, clsPerson p)
{
    out << "Name: " << p._name << ", Age: " << p._age;
    return out;
}
```

### 3. Complex Calculation Functions

```cpp
class clsVector
{
private:
    double _x, _y;
    
public:
    clsVector(double x, double y) : _x(x), _y(y) {}
    
    // Friend function for distance calculation
    friend double Distance(clsVector v1, clsVector v2);
};

double Distance(clsVector v1, clsVector v2)
{
    double dx = v1._x - v2._x;
    double dy = v1._y - v2._y;
    return sqrt(dx*dx + dy*dy);
}
```

## Warnings and Considerations

### Security Risks:
- **Breaking Encapsulation:** Partially destroying the Encapsulation principle
- **Dependency:** Creating dependency relationship between function and class
- **Tracking Difficulty:** Difficulty knowing who accesses private data

### Safe Usage Tips:
1. **Use with caution:** Only when necessary
2. **Document the reason:** Explain why you need Friend Function
3. **Minimize the number:** Don't overuse Friend Functions
4. **Think of alternatives:** Can you use Getter/Setter instead?

## Final Summary

### What are Friend Functions?
**External functions (in the street) that have special privileges to access all members of a specific class.**

### Basic Idea:
- **External function:** Not a member of any class
- **Special privileges:** Can access private, protected, public
- **Miniature bribery:** Precise control over access level
- **Regular calling:** Called like any regular function

### Important Differences:
- **Friend Function ≠ Member Function:** Not a member of the class
- **Friend Function ≠ Normal Function:** Has special privileges
- **Friend Function = Targeted Access:** Specific and precise access

### Important Reminder:
Friend Functions **partially break the Encapsulation principle** but provide **more precise control** than Friend Classes. Use them **wisely and for specific purposes**!

<br><br><br><br><br><br>
---
*Anas Chetoui - `anaschetoui`*
