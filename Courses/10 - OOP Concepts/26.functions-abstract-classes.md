<a id="arabic"></a>
[English ↙](#english)

<div dir="rtl" style="text-align: right">
    
## Interfaces: Pure Virtual Functions and Abstract Classes

## مراجعة الدروس السابقة

في الدروس السابقة تم تعلم:
- **الدوال الافتراضية (Virtual Functions)** العادية
- **تجاوز الدوال (Function Overriding)**
- **الربط الديناميكي (Dynamic Binding)**
- **تعدد الأشكال (Polymorphism)**

## درس اليوم: إبرام الصفقات والعقود

درس اليوم ممتع جداً وهو عن **إبرام الصفقات والعقود** في البرمجة الكائنية. سنتعلم كيف نجبر المطور على تنفيذ طرق معينة بمعاملات محددة وبالأسماء التي نريدها.

### المشكلة في الماضي: الاتفاقات الشفهية

في الماضي، قبل البرمجة الكائنية:
- الاتفاقات كانت **شفهية** بين المطورين
- "يجب أن يكون عندك Function1, Function2, Function3"
- "Function1 يأخذ parameter من نوع integer وparameter من نوع string"
- الاعتماد على **الثقة المتبادلة** وعدم النسيان

### مشاكل الاتفاقات الشفهية:

1. **النسيان:** المطورون ينسون المتطلبات
2. **الأخطاء:** تعريف integer بدلاً من string
3. **عدم الدقة:** function بثلاث معاملات بدل أربعة
4. **عدم التنفيذ:** نسيان عمل implementation لfunction معين

### الحل: العقود المكتوبة

**الكلام الشفهي يجب أن يُكتب في عقد ويوقع عليه المطور**
- **العقد شريعة المتعاقدين**
- عندما توقع على عقد، تلتزم بشروطه

## المفاهيم الجديدة

### 1. الواجهات (Interfaces)
### 2. الفئات المجردة (Abstract Classes)  
### 3. الدوال الافتراضية النقية (Pure Virtual Functions)
### 4. العقود (Contracts)

جميع هذه المفاهيم تحقق نفس الهدف: **إجبار المطور على التقيد بمعايير محددة**.

## الدوال الافتراضية النقية (Pure Virtual Functions)

### مراجعة: الدوال الافتراضية العادية

في الأمثلة السابقة:
- فئة `Person` تحتوي على `Print` مع implementation
- فئة `Student` تعمل Override لـ `Print`
- فئة `Employee` تعمل Override لـ `Print`

هذه نسميها **Virtual Functions عادية**.

### الدوال الافتراضية النقية

</div>

```cpp
class clsMobile
{
    virtual void Dial(string PhoneNumber) = 0;
    virtual void SendSMS(string PhoneNumber, string Text) = 0;
    virtual void TakePicture() = 0;
};
```

<div dir="rtl" style="text-align: right">

### ماذا يعني `= 0`؟

عندما نكتب `= 0` بعد الدالة:
- تصبح **Pure Virtual Function** (دالة افتراضية نقية)
- **Pure** يعني نقية - Virtual Function مئة بالمئة
- **لا يوجد implementation** لها في هذه الفئة
- موجود فقط **الـ Interface** (الواجهة)

### تحويل الفئة إلى Abstract Class

**بمجرد وجود Pure Virtual Function واحدة فقط في الفئة، تتحول إلى Abstract Class**

## الفئات المجردة (Abstract Classes)

### تعريف Abstract Class:
- **فئة عقد (Contract Class)**
- **لا يمكن إنشاء Object منها**
- تحتوي على Interfaces فقط
- لا تحتوي على Implementation

### لماذا لا يمكن إنشاء Object من Abstract Class؟

</div>

```cpp
// هذا الكود سيعطي خطأ!
clsMobile m1; // Error: Cannot instantiate abstract class
```

<div dir="rtl" style="text-align: right">

**السبب:** لأنه لا يوجد implementation للدوال، فقط interfaces.

### رسالة الخطأ:
```
Object of abstract class type 'clsMobile' is not allowed
```

## تطبيق العقود: مثال الموبايل

### فئة الموبايل (العقد الأساسي):

</div>

```cpp
//Abstract Class / Interface / Contract
class clsMobile
{
    virtual void Dial(string PhoneNumber) = 0;
    virtual void SendSMS(string PhoneNumber, string Text) = 0;
    virtual void TakePicture() = 0;
};
```

<div dir="rtl" style="text-align: right">

هذه الفئة تحدد **العقد** الذي يجب على أي موبايل الالتزام به:
1. **Dial:** الاتصال برقم هاتف
2. **SendSMS:** إرسال رسالة نصية
3. **TakePicture:** التقاط صورة

### توقيع العقد: فئة iPhone

</div>

```cpp
class clsiPhone : public clsMobile
{
public:
    void Dial(string PhoneNumber)
    {
        // Implementation for iPhone dialing
    };
  
    void SendSMS(string PhoneNumber, string Text)
    {
        // Implementation for iPhone SMS
    };

    void TakePicture()
    {
        // Implementation for iPhone camera
    };

    // يمكن إضافة دوال إضافية
    void MyOwnMethod()
    {
        // iPhone specific functionality
    }
};
```

<div dir="rtl" style="text-align: right">

### ما حدث هنا؟

1. **فئة iPhone ورثت من clsMobile**
2. **وقعت معها عقد** للالتزام بتنفيذ الدوال الثلاث
3. **أجبرت على التنفيذ** - ليس موضوع شفهي

### دور المترجم كشرطة

عندما تحاول iPhone عدم تنفيذ العقد:

</div>

```cpp
class clsiPhone : public clsMobile
{
    // لم تنفذ الدوال المطلوبة!
};

// محاولة إنشاء Object
clsiPhone phone1; // خطأ!
```

<div dir="rtl" style="text-align: right">

**رسالة الخطأ:**
```
Object of abstract class type 'clsiPhone' is not allowed
```

**المترجم يقول:** "أنت وقعت عقد ولم تلتزم بشروطه!"

### مثال آخر: Samsung Note10

</div>

```cpp
class clsSamsungNote10 : public clsMobile
{
public:
    void Dial(string PhoneNumber)
    {
        // Samsung dialing implementation
    };

    void SendSMS(string PhoneNumber, string Text)
    {
        // Samsung SMS implementation  
    };

    // نسيت تنفيذ TakePicture!
};
```

<div dir="rtl" style="text-align: right">

**النتيجة:** خطأ من المترجم لأن TakePicture لم تنفذ.

### أهمية دقة التوقيع (Signature Matching)

إذا أخطأ المطور في المعاملات:

</div>

```cpp
class clsSamsungNote10 : public clsMobile
{
public:
    void SendSMS(string PhoneNumber) // نسي المعامل الثاني!
    {
        // خطأ في التوقيع
    };
};
```

<div dir="rtl" style="text-align: right">

**المترجم سيعتبرها:** Overloading وليس Overriding
**النتيجة:** خطأ لأن العقد لم ينفذ بالطريقة الصحيحة

## الفروق المهمة

### Abstract Class مقابل Abstraction

**تنبيه مهم:** لا تخلطوا بين:

1. **Abstract Class:** فئة عقد/واجهة (موضوع اليوم)
2. **Abstraction مبدأ:** إخفاء التفاصيل غير الضرورية (مبدأ سابق)

هما مفهومان مختلفان تماماً!

### Interface مقابل Abstract Class

في لغات أخرى:
- **Interface:** نفس مفهوم Abstract Class
- **Abstract Class:** نفس مفهوم Interface
- **Contract:** نفس المفهومين

جميعها تعبر عن **العقود** في البرمجة.

## الكود الكامل مع التوضيحات

</div>

```cpp
#include <iostream>
using namespace std;

//Abstract Class / Interface / Contract
class clsMobile
{
    // Pure Virtual Functions = 0 تعني لا implementation هنا
    virtual void Dial(string PhoneNumber) = 0;
    virtual void SendSMS(string PhoneNumber, string Text) = 0;
    virtual void TakePicture() = 0;
};

class clsiPhone : public clsMobile
{
    // هذه الفئة وقعت عقد مع clsMobile
    // يجب تنفيذ جميع الدوال الموجودة في العقد
public:
    void Dial(string PhoneNumber)
    {
        cout << "iPhone is dialing " << PhoneNumber << endl;
    };
  
    void SendSMS(string PhoneNumber, string Text)
    {
        cout << "iPhone sending SMS to " << PhoneNumber 
             << ": " << Text << endl;
    };

    void TakePicture()
    {
        cout << "iPhone taking picture with advanced camera" << endl;
    };

    // يمكن إضافة دوال خاصة بـ iPhone
    void MyOwnMethod()
    {
        cout << "iPhone specific feature" << endl;
    }
};

class clsSamsungNote10 : public clsMobile
{
    // هذه الفئة أيضاً وقعت عقد مع clsMobile
    // يجب تنفيذ جميع الدوال الموجودة في العقد
public:
    void Dial(string PhoneNumber)
    {
        cout << "Samsung dialing " << PhoneNumber << endl;
    };

    void SendSMS(string PhoneNumber, string Text)
    {
        cout << "Samsung sending SMS to " << PhoneNumber 
             << ": " << Text << endl;
    };

    void TakePicture()
    {
        cout << "Samsung taking picture with S Pen features" << endl;
    };
};

int main()
{
    // الآن يمكن إنشاء Objects لأن العقود نُفذت
    clsiPhone iPhone1;
    clsSamsungNote10 Note10;

    // استخدام الدوال
    iPhone1.Dial("123456789");
    iPhone1.SendSMS("123456789", "Hello from iPhone");
    iPhone1.TakePicture();

    Note10.Dial("987654321");
    Note10.SendSMS("987654321", "Hello from Samsung");
    Note10.TakePicture();

    return 0;
}
```

<div dir="rtl" style="text-align: right">

## الفوائد العملية للـ Interfaces

### 1. في تكامل الشركات
- **مايكروسوفت** تعطي Abstract Class للمطورين
- "اعمل implementation لهذا العقد"
- ضمان التوافق بين جميع الأنظمة

### 2. في العمل الجماعي
- **اتفاق مكتوب** بدلاً من الشفهي
- **تقليل الأخطاء** والنسيان
- **معايير موحدة** لجميع المطورين

### 3. في صيانة الكود
- **المترجم كشرطة** يراقب التنفيذ
- **إجبار المطورين** على الالتزام
- **ضمان اكتمال التنفيذ**

## الأسئلة الشائعة

### هل يمكن إضافة دوال إضافية؟

**نعم!** يمكن للفئة المنفذة إضافة دوال إضافية:

</div>

```cpp
class clsiPhone : public clsMobile
{
    // تنفيذ العقد (إجباري)
    void Dial(string PhoneNumber) { /* ... */ };
    void SendSMS(string PhoneNumber, string Text) { /* ... */ };
    void TakePicture() { /* ... */ };

    // دوال إضافية (اختيارية)
    void FaceID() { /* iPhone specific */ };
    void Siri() { /* iPhone specific */ };
};
```

<div dir="rtl" style="text-align: right">

**"زيادة الخير خيرين"** - لا مشكلة في الدوال الإضافية!

### متى نستخدم Abstract Classes؟

1. **عند التكامل بين الأنظمة**
2. **عند العمل في فرق كبيرة**
3. **عند الحاجة لمعايير موحدة**
4. **عند ضمان تنفيذ دوال معينة**

## الخلاصة النهائية

### المفاهيم الأساسية:
- **Pure Virtual Function:** دالة مع `= 0` (لا implementation)
- **Abstract Class:** فئة تحتوي على Pure Virtual Functions
- **Interface:** نفس مفهوم Abstract Class
- **Contract:** عقد يجب الالتزام به

### القواعد المهمة:
1. **لا يمكن إنشاء Object من Abstract Class**
2. **يجب تنفيذ جميع Pure Virtual Functions**
3. **التوقيع يجب أن يطابق 100%**
4. **يمكن إضافة دوال إضافية**

### الفوائد:
- **تقليل الأخطاء** في البرمجة
- **ضمان التوافق** بين الأنظمة
- **معايير موحدة** للتطوير
- **المترجم كشرطة** يراقب التنفيذ

**تذكر:** Abstract Classes تساعد في إنشاء كود أكثر تنظيماً وأقل أخطاء!

</div>

<br><br><br><br><br><br><br><br><br>

<a id="english"></a>
[العربية ↗](#arabic)

# Interfaces: Pure Virtual Functions and Abstract Classes

## Review of Previous Lessons

In previous lessons, the following concepts were learned:
- **Regular Virtual Functions**
- **Function Overriding**
- **Dynamic Binding**
- **Polymorphism**

## Today's Lesson: Making Deals and Contracts

Today's lesson is very interesting and focuses on **making deals and contracts** in object-oriented programming. We'll learn how to force developers to implement specific methods with certain parameters and the names we want.

### The Problem in the Past: Verbal Agreements

In the past, before object-oriented programming:
- Agreements were **verbal** between developers
- "You must have Function1, Function2, Function3"
- "Function1 takes a parameter of type integer and a parameter of type string"
- Reliance on **mutual trust** and memory

### Problems with Verbal Agreements:

1. **Forgetting:** Developers forget requirements
2. **Errors:** Defining integer instead of string
3. **Inaccuracy:** function with three parameters instead of four
4. **Non-implementation:** Forgetting to implement a specific function

### The Solution: Written Contracts

**Verbal agreements must be written in a contract and signed by the developer**
- **The contract is the law of the contracting parties**
- When you sign a contract, you commit to its terms

## New Concepts

### 1. Interfaces
### 2. Abstract Classes  
### 3. Pure Virtual Functions
### 4. Contracts

All these concepts achieve the same goal: **forcing developers to adhere to specific standards**.

## Pure Virtual Functions

### Review: Regular Virtual Functions

In previous examples:
- `Person` class contains `Print` with implementation
- `Student` class overrides `Print`
- `Employee` class overrides `Print`

These are called **regular Virtual Functions**.

### Pure Virtual Functions

```cpp
class clsMobile
{
    virtual void Dial(string PhoneNumber) = 0;
    virtual void SendSMS(string PhoneNumber, string Text) = 0;
    virtual void TakePicture() = 0;
};
```

### What does `= 0` mean?

When we write `= 0` after the function:
- It becomes a **Pure Virtual Function**
- **Pure** means clean - 100% Virtual Function
- **No implementation** exists for it in this class
- Only the **Interface** exists

### Converting Class to Abstract Class

**As soon as there's just one Pure Virtual Function in the class, it becomes an Abstract Class**

## Abstract Classes

### Definition of Abstract Class:
- **Contract Class**
- **Cannot create Object from it**
- Contains Interfaces only
- Contains no Implementation

### Why can't we create an Object from Abstract Class?

```cpp
// This code will give an error!
clsMobile m1; // Error: Cannot instantiate abstract class
```

**Reason:** Because there's no implementation for the functions, only interfaces.

### Error Message:
```
Object of abstract class type 'clsMobile' is not allowed
```

## Implementing Contracts: Mobile Example

### Mobile Class (Basic Contract):

```cpp
//Abstract Class / Interface / Contract
class clsMobile
{
    virtual void Dial(string PhoneNumber) = 0;
    virtual void SendSMS(string PhoneNumber, string Text) = 0;
    virtual void TakePicture() = 0;
};
```

This class defines the **contract** that any mobile must adhere to:
1. **Dial:** Call a phone number
2. **SendSMS:** Send a text message
3. **TakePicture:** Take a picture

### Signing the Contract: iPhone Class

```cpp
class clsiPhone : public clsMobile
{
public:
    void Dial(string PhoneNumber)
    {
        // Implementation for iPhone dialing
    };
  
    void SendSMS(string PhoneNumber, string Text)
    {
        // Implementation for iPhone SMS
    };

    void TakePicture()
    {
        // Implementation for iPhone camera
    };

    // Additional functions can be added
    void MyOwnMethod()
    {
        // iPhone specific functionality
    }
};
```

### What happened here?

1. **iPhone class inherited from clsMobile**
2. **Signed a contract** to implement the three functions
3. **Forced to implement** - not a verbal matter

### Compiler's Role as Police

When iPhone tries not to implement the contract:

```cpp
class clsiPhone : public clsMobile
{
    // Didn't implement the required functions!
};

// Trying to create Object
clsiPhone phone1; // Error!
```

**Error Message:**
```
Object of abstract class type 'clsiPhone' is not allowed
```

**The compiler says:** "You signed a contract and didn't adhere to its terms!"

### Another Example: Samsung Note10

```cpp
class clsSamsungNote10 : public clsMobile
{
public:
    void Dial(string PhoneNumber)
    {
        // Samsung dialing implementation
    };

    void SendSMS(string PhoneNumber, string Text)
    {
        // Samsung SMS implementation  
    };

    // Forgot to implement TakePicture!
};
```

**Result:** Compiler error because TakePicture wasn't implemented.

### Importance of Signature Matching

If the developer makes an error in parameters:

```cpp
class clsSamsungNote10 : public clsMobile
{
public:
    void SendSMS(string PhoneNumber) // Forgot the second parameter!
    {
        // Error in signature
    };
};
```

**The compiler will consider it:** Overloading, not Overriding
**Result:** Error because the contract wasn't implemented correctly

## Important Differences

### Abstract Class vs Abstraction

**Important Note:** Don't confuse:

1. **Abstract Class:** Contract/interface class (today's topic)
2. **Abstraction Principle:** Hiding unnecessary details (previous principle)

They are completely different concepts!

### Interface vs Abstract Class

In other languages:
- **Interface:** Same concept as Abstract Class
- **Abstract Class:** Same concept as Interface
- **Contract:** Same as both concepts

All express **contracts** in programming.

## Complete Code with Explanations

```cpp
#include <iostream>
using namespace std;

//Abstract Class / Interface / Contract
class clsMobile
{
    // Pure Virtual Functions = 0 means no implementation here
    virtual void Dial(string PhoneNumber) = 0;
    virtual void SendSMS(string PhoneNumber, string Text) = 0;
    virtual void TakePicture() = 0;
};

class clsiPhone : public clsMobile
{
    // This class signed a contract with clsMobile
    // Must implement all functions in the contract
public:
    void Dial(string PhoneNumber)
    {
        cout << "iPhone is dialing " << PhoneNumber << endl;
    };
  
    void SendSMS(string PhoneNumber, string Text)
    {
        cout << "iPhone sending SMS to " << PhoneNumber 
             << ": " << Text << endl;
    };

    void TakePicture()
    {
        cout << "iPhone taking picture with advanced camera" << endl;
    };

    // iPhone-specific functions can be added
    void MyOwnMethod()
    {
        cout << "iPhone specific feature" << endl;
    }
};

class clsSamsungNote10 : public clsMobile
{
    // This class also signed a contract with clsMobile
    // Must implement all functions in the contract
public:
    void Dial(string PhoneNumber)
    {
        cout << "Samsung dialing " << PhoneNumber << endl;
    };

    void SendSMS(string PhoneNumber, string Text)
    {
        cout << "Samsung sending SMS to " << PhoneNumber 
             << ": " << Text << endl;
    };

    void TakePicture()
    {
        cout << "Samsung taking picture with S Pen features" << endl;
    };
};

int main()
{
    // Now Objects can be created because contracts are implemented
    clsiPhone iPhone1;
    clsSamsungNote10 Note10;

    // Using the functions
    iPhone1.Dial("123456789");
    iPhone1.SendSMS("123456789", "Hello from iPhone");
    iPhone1.TakePicture();

    Note10.Dial("987654321");
    Note10.SendSMS("987654321", "Hello from Samsung");
    Note10.TakePicture();

    return 0;
}
```

## Practical Benefits of Interfaces

### 1. In Company Integration
- **Microsoft** provides Abstract Class to developers
- "Implement this contract"
- Ensures compatibility between all systems

### 2. In Teamwork
- **Written agreement** instead of verbal
- **Reduces errors** and forgetting
- **Unified standards** for all developers

### 3. In Code Maintenance
- **Compiler as police** monitors implementation
- **Forces developers** to comply
- **Ensures complete implementation**

## Frequently Asked Questions

### Can additional functions be added?

**Yes!** The implementing class can add additional functions:

```cpp
class clsiPhone : public clsMobile
{
    // Contract implementation (mandatory)
    void Dial(string PhoneNumber) { /* ... */ };
    void SendSMS(string PhoneNumber, string Text) { /* ... */ };
    void TakePicture() { /* ... */ };

    // Additional functions (optional)
    void FaceID() { /* iPhone specific */ };
    void Siri() { /* iPhone specific */ };
};
```

**"More good is better"** - no problem with additional functions!

### When do we use Abstract Classes?

1. **When integrating between systems**
2. **When working in large teams**
3. **When needing unified standards**
4. **When ensuring specific functions are implemented**

## Final Summary

### Basic Concepts:
- **Pure Virtual Function:** Function with `= 0` (no implementation)
- **Abstract Class:** Class containing Pure Virtual Functions
- **Interface:** Same concept as Abstract Class
- **Contract:** Agreement that must be adhered to

### Important Rules:
1. **Cannot create Object from Abstract Class**
2. **Must implement all Pure Virtual Functions**
3. **Signature must match 100%**
4. **Additional functions can be added**

### Benefits:
- **Reduces errors** in programming
- **Ensures compatibility** between systems
- **Unified standards** for development
- **Compiler as police** monitors implementation

**Remember:** Abstract Classes help create more organized code with fewer errors!
<br><br><br><br>
---
*Anas Chetoui - `anaschetoui`*
