<a id="arabic"></a>
[English ↙](#english)

<div dir="rtl" style="text-align: right;">

# ما هو مؤشر this؟ (What is 'this' pointer?)

## المفهوم الأساسي

**مؤشر this** هو كلمة مفتاحية (keyword) في C++ تُسمى **This Pointer**.

### التعريف:
- **this** = مؤشر يشير إلى **الكائن الحالي** (Current Object)
- **this** = العنوان الخاص بالـ **Current Instance** من الفئة
- **this** متاح فقط **داخل دوال الفئة** (Class Member Functions)

## الاستخدام الضمني (Implicit Usage)

**الحقيقة المخفية:** المترجم (Compiler) يستخدم **this** تلقائياً خلف الكواليس!

### مثال توضيحي:

</div>

```cpp
class clsEmployee 
{
public:
    int ID;     
    string Name; 
    float Salary;

    void Print()
    {
        // ما تكتبه أنت:
        cout << ID << "  " << Name << "  " << Salary << endl;
        
        // ما يفهمه المترجم فعلياً:
        cout << this->ID << "  " << this->Name << "  " << this->Salary << endl;
    }
};
```

<div dir="rtl" style="text-align: right;">

### كيف يعمل المترجم؟

</div>

```cpp
// الكود الأصلي (الذي تكتبه):
ID = 100;
Name = "Ali";

// ما يحدث خلف الكواليس:
this->ID = 100;
this->Name = "Ali";
```

<div dir="rtl" style="text-align: right;">

**السبب:** المترجم "محترم ومُريح" - يضع **this** تلقائياً لتوفير الوقت!

## الاستخدام الصريح (Explicit Usage)

### الحالة الأولى: تعارض الأسماء

**المشكلة:** عندما يكون اسم المتغير نفس اسم الخاصية

</div>

```cpp
class clsEmployee 
{
public:
    int ID;     
    string Name; 
    float Salary;

    // ❌ مشكلة: تعارض في الأسماء
    clsEmployee(int ID, string Name, float Salary)
    {
        ID = ID;        // أي ID؟ المتغير أم الخاصية؟
        Name = Name;    // المترجم محتار!
        Salary = Salary;
    }
};
```

<div dir="rtl" style="text-align: right;">

**الحل:** استخدام **this** للتمييز

</div>

```cpp
class clsEmployee 
{
public:
    int ID;     
    string Name; 
    float Salary;

    // ✅ الحل الصحيح
    clsEmployee(int ID, string Name, float Salary)
    {
        this->ID = ID;        // خاصية الكائن = المتغير المُمرر
        this->Name = Name;    // واضح ومفهوم!
        this->Salary = Salary;
    }
};
```

<div dir="rtl" style="text-align: right;">

### التفسير:
- **`this->ID`** = خاصية الكائن
- **`ID`** = المتغير المُمرر للدالة

## الحالة الثانية: إرسال الكائن الحالي

### المشكلة: كيف أُرسل الكائن الحالي لدالة أخرى؟

**السيناريو:** دالة static تحتاج كائن كامل

</div>

```cpp
class clsEmployee 
{
public:
    int ID;     
    string Name; 
    float Salary;

    // دالة static - لا تملك وصول للكائن الحالي
    static void Func1(clsEmployee Employee)
    {
        Employee.Print();  // تطبع بيانات الكائن المُمرر
    }

    // دالة عادية - تملك وصول للكائن الحالي
    void Func2()
    {
        // كيف أُرسل الكائن الحالي لـ Func1؟
        Func1(*this);  // الحل: *this
    }

    void Print()
    {
        cout << ID << "  " << Name << "  " << Salary << endl;
    }
};
```

<div dir="rtl" style="text-align: right;">

### شرح **`*this`**:
- **`this`** = مؤشر للكائن الحالي
- **`*this`** = الكائن الحالي نفسه (إلغاء الإشارة)

## المثال الكامل: التطبيق العملي

</div>

```cpp
#include <iostream>  
using namespace std;

class clsEmployee 
{
public:
    int ID;     
    string Name; 
    float Salary;

    clsEmployee(int ID, string Name, float Salary)
    {
        this->ID = ID;        // ضروري لتجنب التعارض
        this->Name = Name;
        this->Salary = Salary;
    }

    static void Func1(clsEmployee Employee)
    {
        cout << "From Static Function: ";
        Employee.Print();
    }

    void Func2()
    {
        Func1(*this);  // إرسال الكائن الحالي
    }

    void Print()
    {
        cout << ID << "  " << Name << "  " << Salary << endl;
    }
};

int main()
{
    clsEmployee Employee1(101, "Ali", 5000); 
    
    Employee1.Print();  // طباعة مباشرة
    Employee1.Func2();  // طباعة عبر Static Function
    
    return 0;
}
```

<div dir="rtl" style="text-align: right;">

### النتيجة المتوقعة:

</div>

```
101  Ali  5000
From Static Function: 101  Ali  5000
```

<div dir="rtl" style="text-align: right;">

## القيود والاستثناءات

### أين يمكن استخدام **this**؟
- ✅ **داخل دوال الفئة العادية**
- ✅ **داخل دوال الفئة الافتراضية (Constructors)**
- ✅ **داخل دوال الفئة المدمرة (Destructors)**

### أين لا يمكن استخدام **this**؟
- ❌ **داخل الدوال Static** (لا تملك كائن!)
- ❌ **داخل Friend Functions** (ليست عضو في الفئة)

## مقارنة مع اللغات الأخرى

| اللغة | الكلمة المفتاحية | المثال |
|-------|------------------|---------|
| **C++** | `this` | `this->ID` |
| **Visual Basic** | `me` | `me.ID` |
| **C#** | `this` | `this.ID` |
| **Java** | `this` | `this.ID` |

## الحالات الأساسية لاستخدام **this**

### 1. تعارض الأسماء (Name Conflicts)

</div>

```cpp
void setID(int ID) 
{
    this->ID = ID;  // ضروري للتمييز
}
```

<div dir="rtl" style="text-align: right;">

### 2. إرسال الكائن الحالي

</div>

```cpp
void sendToAnotherFunction() 
{
    someFunction(*this);  // إرسال الكائن كاملاً
}
```

<div dir="rtl" style="text-align: right;">

### 3. إرجاع الكائن الحالي

</div>

```cpp
clsEmployee& setSalary(float salary) 
{
    this->Salary = salary;
    return *this;  // للتسلسل: obj.setSalary(5000).Print()
}
```

<div dir="rtl" style="text-align: right;">

## أفضل الممارسات

### متى تستخدم **this** صراحة؟
1. **عند تعارض الأسماء** - ضروري
2. **عند إرسال الكائن الحالي** - مفيد
3. **لوضوح الكود** - اختياري

### متى لا تحتاج **this**؟
- **الوصول العادي للخصائص** - المترجم يضعها تلقائياً
- **استدعاء الدوال العادية** - غير ضروري

## الخلاصة

### النقاط المهمة:
1. **this** = مؤشر للكائن الحالي
2. **المترجم يستخدمها تلقائياً** في معظم الحالات
3. **الاستخدام الصريح ضروري** في حالات محددة
4. **غير متاح في Static Functions** أو Friend Functions

### الاستخدامات الأساسية:
- **حل تعارض الأسماء:** `this->ID = ID`
- **إرسال الكائن الحالي:** `function(*this)`
- **تحسين وضوح الكود:** `this->member`

**تذكر:** **this** هو جسرك للوصول إلى الكائن الحالي من داخل دوال الفئة!

</div>

<br><br><br><br><br><br><br><br><br>

<a id="english"></a>
[العربية ↗](#arabic)

# What is 'this' pointer?

## Basic Concept

**this pointer** is a keyword in C++ called **This Pointer**.

### Definition:
- **this** = pointer that points to the **Current Object**
- **this** = address of the **Current Instance** of the class
- **this** is available only **inside Class Member Functions**

## Implicit Usage

**Hidden Truth:** The Compiler uses **this** automatically behind the scenes!

### Illustrative Example:

```cpp
class clsEmployee 
{
public:
    int ID;     
    string Name; 
    float Salary;

    void Print()
    {
        // What you write:
        cout << ID << "  " << Name << "  " << Salary << endl;
        
        // What compiler actually understands:
        cout << this->ID << "  " << this->Name << "  " << this->Salary << endl;
    }
};
```

### How Does the Compiler Work?

```cpp
// Original code (what you write):
ID = 100;
Name = "Ali";

// What happens behind the scenes:
this->ID = 100;
this->Name = "Ali";
```

**Reason:** The compiler is "respectful and convenient" - it adds **this** automatically to save time!

## Explicit Usage

### Case 1: Name Conflicts

**Problem:** When parameter name is the same as property name

```cpp
class clsEmployee 
{
public:
    int ID;     
    string Name; 
    float Salary;

    // ❌ Problem: Name conflicts
    clsEmployee(int ID, string Name, float Salary)
    {
        ID = ID;        // Which ID? Parameter or property?
        Name = Name;    // Compiler is confused!
        Salary = Salary;
    }
};
```

**Solution:** Use **this** for distinction

```cpp
class clsEmployee 
{
public:
    int ID;     
    string Name; 
    float Salary;

    // ✅ Correct solution
    clsEmployee(int ID, string Name, float Salary)
    {
        this->ID = ID;        // Object property = passed parameter
        this->Name = Name;    // Clear and understandable!
        this->Salary = Salary;
    }
};
```

### Explanation:
- **`this->ID`** = object property
- **`ID`** = parameter passed to function

## Case 2: Passing Current Object

### Problem: How do I pass the current object to another function?

**Scenario:** Static function needs complete object

```cpp
class clsEmployee 
{
public:
    int ID;     
    string Name; 
    float Salary;

    // Static function - has no access to current object
    static void Func1(clsEmployee Employee)
    {
        Employee.Print();  // Prints data of passed object
    }

    // Regular function - has access to current object
    void Func2()
    {
        // How do I pass current object to Func1?
        Func1(*this);  // Solution: *this
    }

    void Print()
    {
        cout << ID << "  " << Name << "  " << Salary << endl;
    }
};
```

### Explanation of **`*this`**:
- **`this`** = pointer to current object
- **`*this`** = current object itself (dereferencing)

## Complete Example: Practical Application

```cpp
#include <iostream>  
using namespace std;

class clsEmployee 
{
public:
    int ID;     
    string Name; 
    float Salary;

    clsEmployee(int ID, string Name, float Salary)
    {
        this->ID = ID;        // Necessary to avoid conflicts
        this->Name = Name;
        this->Salary = Salary;
    }

    static void Func1(clsEmployee Employee)
    {
        cout << "From Static Function: ";
        Employee.Print();
    }

    void Func2()
    {
        Func1(*this);  // Pass current object
    }

    void Print()
    {
        cout << ID << "  " << Name << "  " << Salary << endl;
    }
};

int main()
{
    clsEmployee Employee1(101, "Ali", 5000); 
    
    Employee1.Print();  // Direct printing
    Employee1.Func2();  // Printing via Static Function
    
    return 0;
}
```

### Expected Output:

```
101  Ali  5000
From Static Function: 101  Ali  5000
```

## Limitations and Exceptions

### Where can you use **this**?
- ✅ **Inside regular class functions**
- ✅ **Inside constructors**
- ✅ **Inside destructors**

### Where can't you use **this**?
- ❌ **Inside Static functions** (no object!)
- ❌ **Inside Friend Functions** (not class member)

## Comparison with Other Languages

| Language | Keyword | Example |
|----------|---------|---------|
| **C++** | `this` | `this->ID` |
| **Visual Basic** | `me` | `me.ID` |
| **C#** | `this` | `this.ID` |
| **Java** | `this` | `this.ID` |

## Basic Cases for Using **this**

### 1. Name Conflicts

```cpp
void setID(int ID) 
{
    this->ID = ID;  // Necessary for distinction
}
```

### 2. Passing Current Object

```cpp
void sendToAnotherFunction() 
{
    someFunction(*this);  // Pass complete object
}
```

### 3. Returning Current Object

```cpp
clsEmployee& setSalary(float salary) 
{
    this->Salary = salary;
    return *this;  // For chaining: obj.setSalary(5000).Print()
}
```

## Best Practices

### When to use **this** explicitly?
1. **When names conflict** - necessary
2. **When passing current object** - useful
3. **For code clarity** - optional

### When don't you need **this**?
- **Regular property access** - compiler adds automatically
- **Regular function calls** - not necessary

## Summary

### Important Points:
1. **this** = pointer to current object
2. **Compiler uses it automatically** in most cases
3. **Explicit usage necessary** in specific cases
4. **Not available in Static Functions** or Friend Functions

### Basic Uses:
- **Resolve name conflicts:** `this->ID = ID`
- **Pass current object:** `function(*this)`
- **Improve code clarity:** `this->member`

**Remember:** **this** is your bridge to access the current object from within class functions!
<br><br><br>

---
*Anas Chetoui - `anaschetoui`*
