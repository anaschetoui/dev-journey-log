<a id="arabic"></a>
[English ↙](#english)

<div dir="rtl" style="text-align: right">

# الدوال الافتراضية (Virtual Functions)

## مراجعة الدرس السابق

في الدرس السابق تعلمنا:
- **Up Casting vs Down Casting**
- **Up Casting:** التحويل من الفئة المشتقة إلى الفئة الأساسية (مسموح) ✅
- **Down Casting:** التحويل من الفئة الأساسية إلى الفئة المشتقة (ممنوع) ❌
- **استخدام المؤشرات** للإشارة إلى كائنات مختلفة

## ما هي الدوال الافتراضية؟

ستفاجأ بأنك تعرف 95% من الدوال الافتراضية، إنما توجد نقطة صغيرة يجب أن نفهمها.

## الكود الأساسي

</div>

```cpp
class clsPerson
{
public:
    void Print()
    {
        cout << "Hi, i'm a person!\n ";
    }
};

class clsEmployee : public clsPerson
{
public:
    void Print()
    {
        cout << "Hi, I'm an Employee\n";
    }
};

class clsStudent : public clsPerson
{
public:
    void Print() 
    {
        cout << "Hi, I'm a student\n";
    }
};
```

<div dir="rtl" style="text-align: right">

## الاستخدام العادي

</div>

```cpp
int main()
{
    clsEmployee Employee1;
    clsStudent Student1;

    Employee1.Print();  // Hi, I'm an Employee
    Student1.Print();   // Hi, I'm a student
    
    return 0;
}
```

<div dir="rtl" style="text-align: right">

هذا يعمل بشكل طبيعي:
- `Employee1.Print()` تطبع "Hi, I'm an Employee"
- `Student1.Print()` تطبع "Hi, I'm a student"

كل كائن ينادي الدالة `Print` الخاصة به.

## ظهور المشكلة مع المؤشرات

</div>

```cpp
int main()
{
    clsEmployee Employee1;
    clsStudent Student1;

    // Up Casting
    clsPerson* Person1 = &Employee1;
    clsPerson* Person2 = &Student1;

    Person1->Print();
    Person2->Print();
    
    return 0;
}
```

<div dir="rtl" style="text-align: right">

**النتيجة المفاجئة:**
- `Hi, i'm a person!`
- `Hi, i'm a person!`

## سبب هذه المشكلة

عندما استخدمنا المؤشرات:
- `Employee` ترث من `Person`
- `Student` ترث من `Person`

عند استدعاء الدالة `Print` من خلال المؤشرات، صارت خربطة. المؤشر `Person1` من نوع `Person` يشير إلى `Employee`، والمؤشر `Person2` من نوع `Person` يشير إلى `Student`، فصارت مشاكل في الاستدعاء.

## الحل: الدوال الافتراضية

لحل هذه المشكلة وتجنب الخربطة عند استخدام المؤشرات، نضيف الكلمة المفتاحية `virtual`:

</div>

```cpp
class clsPerson
{
public:
    virtual void Print()  // إضافة virtual
    {
        cout << "Hi, i'm a person!\n ";
    }
};

class clsEmployee : public clsPerson
{
public:
    void Print()
    {
        cout << "Hi, I'm an Employee\n";
    }
};

class clsStudent : public clsPerson
{
public:
    void Print() 
    {
        cout << "Hi, I'm a student\n";
    }
};
```

<div dir="rtl" style="text-align: right">

## النتيجة الصحيحة

</div>

```cpp
int main()
{
    clsEmployee Employee1;
    clsStudent Student1;

    clsPerson* Person1 = &Employee1;
    clsPerson* Person2 = &Student1;

    Person1->Print();  // Hi, I'm an Employee
    Person2->Print();  // Hi, I'm a student
    
    return 0;
}
```

<div dir="rtl" style="text-align: right">

الآن تطبع:
- `Hi, I'm an Employee`
- `Hi, I'm a student`

## وظيفة الكلمة المفتاحية Virtual

الكلمة المفتاحية **Virtual** تُعلِم المترجم بأن هذه الدالة هي دالة افتراضية، وأنه في سياق الوراثة والمؤشرات، يجب الانتباه إليها بشكل خاص.

## آلية عمل الدوال الافتراضية

عند استخدام `virtual`، ينشئ المترجم في الذاكرة جدولاً يُسمى **Virtual Table** (جدول الدوال الافتراضية)، يحتوي على عناوين الدوال لتجنب الخربطة في الاستدعاء.

الكلمة المفتاحية **Virtual** هي تنبيه للمترجم بأن هذه الدالة ستخضع لعملية Override، فيجب الانتباه إليها لتجنب الأخطاء.

## الرسم التوضيحي لآلية العمل

### بدون الدوال الافتراضية:

</div>

```
الربط وقت التجميع (Compile Time Binding):

clsEmployee Employee1;
clsPerson* Person1 = &Employee1;

Person1->Print();
    ↓
المترجم يحدد: Person1 نوعه Person*
    ↓
يستدعي: Person::Print()
    ↓
النتيجة: "Hi, i'm a person!" ❌
```

<div dir="rtl" style="text-align: right">

### مع الدوال الافتراضية:

</div>

```
الربط وقت التشغيل (Runtime Binding):

┌─────────────────────────────────────────────────────────┐
│                  جداول الدوال الافتراضية                │
├─────────────────────────────────────────────────────────┤
│                                                         │
│ clsPerson V-Table:        clsEmployee V-Table:          │
│ ┌─────────────────┐      ┌─────────────────────┐        │
│ │ Person::Print() │      │ Employee::Print()   │        │
│ └─────────────────┘      └─────────────────────┘        │
│                                                         │
│ clsStudent V-Table:                                     │
│ ┌─────────────────────┐                                 │
│ │ Student::Print()    │                                 │
│ └─────────────────────┘                                 │
└─────────────────────────────────────────────────────────┘

عملية الاستدعاء:
clsEmployee Employee1;
clsPerson* Person1 = &Employee1;

Person1->Print();
    ↓
1. Person1 يشير إلى كائن Employee
    ↓
2. كائن Employee يحتوي على مؤشر إلى Employee V-Table
    ↓
3. من Employee V-Table نحصل على عنوان Employee::Print()
    ↓
4. نستدعي Employee::Print()
    ↓
النتيجة: "Hi, I'm an Employee" ✓
```

<div dir="rtl" style="text-align: right">

## جدول الدوال الافتراضية بالتفصيل

</div>

```
حالة الذاكرة عند إنشاء الكائنات:

كائن Employee1:                     كائن Student1:
┌─────────────────┐                ┌─────────────────┐
│ مؤشر V-Table   │─────┐          │ مؤشر V-Table   │─────┐
│ بيانات Employee │     │          │ بيانات Student  │     │
└─────────────────┘     │          └─────────────────┘     │
                        │                                  │
                        ▼                                  ▼
                Employee V-Table:               Student V-Table:
                ┌─────────────────┐             ┌─────────────────┐
                │Employee::Print()│             │Student::Print() │
                └─────────────────┘             └─────────────────┘

عند استدعاء Person1->Print():
Person1 → Employee1 → Employee V-Table → Employee::Print()

عند استدعاء Person2->Print():
Person2 → Student1 → Student V-Table → Student::Print()
```

<div dir="rtl" style="text-align: right">

## المقارنة بين النهجين

### الدوال العادية (غير الافتراضية):
- **تحديد الاستدعاء:** وقت التجميع
- **السرعة:** أسرع
- **استهلاك الذاكرة:** أقل
- **المرونة مع المؤشرات:** محدودة

### الدوال الافتراضية:
- **تحديد الاستدعاء:** وقت التشغيل
- **السرعة:** أبطأ قليلاً
- **استهلاك الذاكرة:** جدول افتراضي إضافي
- **المرونة مع المؤشرات:** تعمل بشكل صحيح

## متى نستخدم الدوال الافتراضية؟

### الحالات المناسبة:
1. **عند تطبيق Override** للدوال في الفئات المشتقة
2. **عند استخدام مؤشرات الفئة الأساسية** للإشارة إلى كائنات الفئات المشتقة
3. **عندما نريد ضمان استدعاء النسخة الصحيحة** من الدالة

### القاعدة الأساسية:
**إذا كنت تتوقع تطبيق Override للدالة وستستخدم المؤشرات، أضف virtual في الفئة الأساسية.**

## الخلاصة

الكلمة المفتاحية **Virtual** تُخبر المترجم: "هذه الدالة ستخضع لعملية Override، فلا تحدد وقت التجميع أي دالة تستدعي، بل انتظر وقت التشغيل واستدعي الدالة الصحيحة بناءً على نوع الكائن الفعلي."

هذا جوهر الدوال الافتراضية - آلية بسيطة تحل مشكلة معقدة في التعامل مع المؤشرات والوراثة.

</div>

<br><br><br><br><br><br><br><br><br>

<a id="english"></a>
[العربية ↗](#arabic)

# Virtual Functions

## Review of Previous Lesson

In the previous lesson we learned:
- **Up Casting vs Down Casting**
- **Up Casting:** Converting from Derived Class to Base Class (allowed) ✅
- **Down Casting:** Converting from Base Class to Derived Class (forbidden) ❌
- **Using Pointers** to point to different objects

## What are Virtual Functions?

You'll be surprised that you know 95% of Virtual Functions, there's just a small thing we need to understand.

## Our Basic Code

```cpp
class clsPerson
{
public:
    void Print()
    {
        cout << "Hi, i'm a person!\n ";
    }
};

class clsEmployee : public clsPerson
{
public:
    void Print()
    {
        cout << "Hi, I'm an Employee\n";
    }
};

class clsStudent : public clsPerson
{
public:
    void Print() 
    {
        cout << "Hi, I'm a student\n";
    }
};
```

## Normal Usage

```cpp
int main()
{
    clsEmployee Employee1;
    clsStudent Student1;

    Employee1.Print();  // Hi, I'm an Employee
    Student1.Print();   // Hi, I'm a student
    
    return 0;
}
```

This works normally:
- `Employee1.Print()` prints "Hi, I'm an Employee"
- `Student1.Print()` prints "Hi, I'm a student"

Each object calls its own `Print` method.

## The Problem Appears with Pointers

```cpp
int main()
{
    clsEmployee Employee1;
    clsStudent Student1;

    // Up Casting
    clsPerson* Person1 = &Employee1;
    clsPerson* Person2 = &Student1;

    Person1->Print();
    Person2->Print();
    
    return 0;
}
```

**Surprising Result:**
- `Hi, i'm a person!`
- `Hi, i'm a person!`

## Cause of This Problem

When we used pointers:
- `Employee` inherits from `Person`
- `Student` inherits from `Person`

When calling the `Print` method through pointers, confusion occurred. Pointer `Person1` of type `Person` points to `Employee`, and pointer `Person2` of type `Person` points to `Student`, causing problems in the calling process.

## The Solution: Virtual Functions

To solve this problem and avoid confusion when using pointers, we add the `virtual` keyword:

```cpp
class clsPerson
{
public:
    virtual void Print()  // Adding virtual
    {
        cout << "Hi, i'm a person!\n ";
    }
};

class clsEmployee : public clsPerson
{
public:
    void Print()
    {
        cout << "Hi, I'm an Employee\n";
    }
};

class clsStudent : public clsPerson
{
public:
    void Print() 
    {
        cout << "Hi, I'm a student\n";
    }
};
```

## The Correct Result

```cpp
int main()
{
    clsEmployee Employee1;
    clsStudent Student1;

    clsPerson* Person1 = &Employee1;
    clsPerson* Person2 = &Student1;

    Person1->Print();  // Hi, I'm an Employee
    Person2->Print();  // Hi, I'm a student
    
    return 0;
}
```

Now it prints:
- `Hi, I'm an Employee`
- `Hi, I'm a student`

## Function of the Virtual Keyword

The **Virtual** keyword informs the compiler that this function is a virtual function, and that in the context of inheritance and pointers, special attention must be paid to it.

## How Virtual Functions Work

When using `virtual`, the compiler creates in memory a table called **Virtual Table**, containing function addresses to avoid confusion in calling.

The **Virtual** keyword is a notification to the compiler that this function will undergo Override, so attention must be paid to it to avoid errors.

## Visual Diagram of How It Works

### Without Virtual Functions:

```
Compile Time Binding:

clsEmployee Employee1;
clsPerson* Person1 = &Employee1;

Person1->Print();
    ↓
Compiler determines: Person1 type is Person*
    ↓
Calls: Person::Print()
    ↓
Result: "Hi, i'm a person!" ❌
```

### With Virtual Functions:

```
Runtime Binding:

┌─────────────────────────────────────────────────────────┐
│                    Virtual Tables                        │
├─────────────────────────────────────────────────────────┤
│                                                         │
│ clsPerson V-Table:        clsEmployee V-Table:          │
│ ┌─────────────────┐      ┌─────────────────────┐        │
│ │ Person::Print() │      │ Employee::Print()   │        │
│ └─────────────────┘      └─────────────────────┘        │
│                                                         │
│ clsStudent V-Table:                                     │
│ ┌─────────────────────┐                                 │
│ │ Student::Print()    │                                 │
│ └─────────────────────┘                                 │
└─────────────────────────────────────────────────────────┘

Call Process:
clsEmployee Employee1;
clsPerson* Person1 = &Employee1;

Person1->Print();
    ↓
1. Person1 points to Employee object
    ↓
2. Employee object contains pointer to Employee V-Table
    ↓
3. From Employee V-Table we get Employee::Print() address
    ↓
4. Call Employee::Print()
    ↓
Result: "Hi, I'm an Employee" ✓
```

## Virtual Table in Detail

```
Memory state when creating objects:

Employee1 Object:                    Student1 Object:
┌─────────────────┐                ┌─────────────────┐
│ V-Table Pointer │─────┐          │ V-Table Pointer │─────┐
│ Employee Data   │     │          │ Student Data    │     │
└─────────────────┘     │          └─────────────────┘     │
                        │                                  │
                        ▼                                  ▼
                Employee V-Table:               Student V-Table:
                ┌─────────────────┐             ┌─────────────────┐
                │Employee::Print()│             │Student::Print() │
                └─────────────────┘             └─────────────────┘

When calling Person1->Print():
Person1 → Employee1 → Employee V-Table → Employee::Print()

When calling Person2->Print():
Person2 → Student1 → Student V-Table → Student::Print()
```

## Comparison Between Approaches

### Regular Functions (Non-Virtual):
- **Call Determination:** Compile time
- **Speed:** Faster
- **Memory Usage:** Less
- **Flexibility with Pointers:** Limited

### Virtual Functions:
- **Call Determination:** Runtime
- **Speed:** Slightly slower
- **Memory Usage:** Additional virtual table
- **Flexibility with Pointers:** Works correctly

## When to Use Virtual Functions?

### Appropriate Cases:
1. **When applying Override** for functions in derived classes
2. **When using base class pointers** to point to derived class objects
3. **When we want to ensure calling the correct version** of the function

### Basic Rule:
**If you expect Override for the function and will use pointers, add virtual in the base class.**

## Summary

The **Virtual** keyword tells the compiler: "This function will undergo Override, so don't determine at compile time which function to call, but wait until runtime and call the correct function based on the actual object type."

This is the essence of Virtual Functions - a simple mechanism that solves a complex problem in dealing with pointers and inheritance.
<br><br><br><br>
---
*Anas Chetoui - `anaschetoui`*
