<a id="arabic"></a>
[English ↙](#english)

<div dir="rtl" style="text-align: right">

# Up Casting vs Down Casting

## مراجعة الدرس السابق

في الدرس السابق تعلمنا:
- **Inheritance Types:** Single, Multi-Level, Hierarchical, Multiple, Hybrid
- **الأنواع الآمنة:** Single, Multi-Level, Hierarchical
- **الأنواع الخطيرة:** Multiple, Hybrid (تجنبهما نهائياً)

## ما هو الـ Casting؟

**Casting** يعني تحويل النوع من Type إلى Type آخر.

### أمثلة من الـ Basic Types:
- **int** إلى **double**
- **string** إلى **int** 
- **double** إلى **int**

هذا ما تعلمناه في دورات C++ الأساسية.

## الـ Casting في OOP

في الـ **Object Oriented Programming** مع **Inheritance**، يوجد نوعان من الـ Casting:

1. **Up Casting** ✅ (مسموح وآمن)
2. **Down Casting** ❌ (ممنوع وخطير)

## فهم العلاقة بين الكلاسات

### مثالنا الأساسي:

</div>

```cpp
class clsPerson
{
public:
    string FullName = "Mohammed Abu-Hadhoud";
};

class clsEmployee : public clsPerson
{
public:
    string Title = "CEO";
};
```

<div dir="rtl" style="text-align: right">

### تحليل العلاقة:
- **Person** = Base Class (الكلاس الأساسي)
- **Employee** = Derived Class (الكلاس المشتق)
- **Employee** يحتوي على كل ما في **Person** + المزيد

### تمثيل بصري للحجم:

</div>

```
┌─────────────────┐
│    Employee     │ ← كبير (يحتوي على كل شيء)
│  ┌───────────┐  │
│  │  Person   │  │ ← صغير (جزء من Employee)
│  │ FullName  │  │
│  └───────────┘  │
│     Title       │
└─────────────────┘
```

<div dir="rtl" style="text-align: right">

## Up Casting ✅

### التعريف:
**تحويل من Derived Class إلى Base Class**

### المبدأ:
- من **كبير** إلى **صغير** ✅
- من **Employee** إلى **Person** ✅

### لماذا مسموح؟
لأن **Employee** يحتوي على **Person** بداخله، فمن المنطقي أن نستخرج الجزء الخاص بـ **Person**.

### التطبيق العملي:

</div>

```cpp
int main()
{
    // إنشاء Employee object
    clsEmployee Employee1;
    cout << Employee1.FullName << endl;  // محمد أبو هدهود
    
    // Up Casting ✅
    clsPerson* Person1 = &Employee1;  // Person pointer يشير على Employee
    cout << Person1->FullName << endl;  // محمد أبو هدهود (نفس النتيجة)
    
    return 0;
}
```

<div dir="rtl" style="text-align: right">

### الرسم التوضيحي للـ Up Casting:

</div>

```
Employee object → Person pointer

┌─────────────────┐
│   Employee1     │
│  ┌───────────┐  │
│  │ FullName  │  │ ← Person1 يصل لهذا الجزء فقط
│  └───────────┘  │
│     Title       │ ← لا يمكن الوصول إليه
└─────────────────┘

Person1 → Employee1.FullName ✓
Person1 → Employee1.Title ✗ (غير متاح)
```

<div dir="rtl" style="text-align: right">

### لماذا لا يمكن الوصول للـ Title؟

لأن **Person1** هو pointer من نوع **Person**، فيمكنه الوصول فقط للأعضاء الموجودة في **Person Class**.

## Down Casting ❌

### التعريف:
**تحويل من Base Class إلى Derived Class**

### المبدأ:
- من **صغير** إلى **كبير** ❌
- من **Person** إلى **Employee** ❌

### لماذا ممنوع؟

</div>

```cpp
int main()
{
    // إنشاء Person object
    clsPerson Person2;
    cout << Person2.FullName << endl;  // محمد أبو هدهود
    
    // Down Casting ❌
    // clsEmployee* Employee2 = &Person2;  // خطأ! لن يتم التجميع
    
    return 0;
}
```

<div dir="rtl" style="text-align: right">

### لماذا لا يعمل؟

</div>

```
Person2 object:
┌───────────┐
│ FullName  │ ← يحتوي على FullName فقط
└───────────┘

Employee pointer يريد:
┌─────────────────┐
│   Employee      │
│  ┌───────────┐  │
│  │ FullName  │  │ ← موجود
│  └───────────┘  │  
│     Title       │ ← غير موجود! من أين سنحصل عليه؟
└─────────────────┘
```

<div dir="rtl" style="text-align: right">

**المشكلة:** الـ **Person** لا يحتوي على **Title**، فمن أين سيحصل الـ **Employee pointer** على هذا المتغير؟

## الرسم توضيحي 

### Up Casting (مسموح):

</div>

```
Person ←── Employee
  ↑    ✓    
Up Casting

Employee يمكن تحويله إلى Person من خلال pointers
```

<div dir="rtl" style="text-align: right">

### Down Casting (ممنوع):

</div>

```
Person ──── Employee
  ↓    ✗
Down Casting

Person لا يمكن تحويله إلى Employee من خلال pointers
```

<div dir="rtl" style="text-align: right">

## القاعدة الذهبية

### ✅ مسموح:
**Base Class Pointer** يمكنه الإشارة على **Derived Class Object**

### ❌ ممنوع:
**Derived Class Pointer** لا يمكنه الإشارة على **Base Class Object**

## لماذا هذه القاعدة؟

### منطق الذاكرة:
- **Employee** = **Person** + إضافات
- عندما نحول **Employee** إلى **Person**: نتجاهل الإضافات ✓
- عندما نحول **Person** إلى **Employee**: نحتاج إضافات غير موجودة ✗

### تشبيه بصري:
- **Employee** مثل صندوق كبير يحتوي على صندوق صغير (**Person**)
- يمكننا استخراج الصندوق الصغير من الكبير ✓
- لا يمكننا وضع الصندوق الصغير في مكان الكبير ✗

## جدول المقارنة

| العنصر | Up Casting | Down Casting |
|--------|------------|-------------|
| **الاتجاه** | Derived → Base | Base → Derived |
| **الحجم** | كبير → صغير | صغير → كبير |
| **الأمان** | ✅ آمن | ❌ خطير |
| **الإجازة** | ✅ مسموح | ❌ ممنوع |
| **المثال** | Employee → Person | Person → Employee |

## التطبيق العملي

### استخدام Up Casting:

</div>

```cpp
// دالة تتعامل مع Person
void PrintPersonInfo(clsPerson* person)
{
    cout << "Name: " << person->FullName << endl;
    // لا يمكن الوصول لـ Title هنا
}

int main()
{
    clsEmployee emp;
    clsPerson person;
    
    // يمكن تمرير Employee للدالة (Up Casting)
    PrintPersonInfo(&emp);     // ✓ يعمل
    PrintPersonInfo(&person);  // ✓ يعمل
    
    return 0;
}
```

<div dir="rtl" style="text-align: right">

## أفضل الممارسات

### ✅ افعل:
1. **استخدم Up Casting** عند الحاجة للتعامل مع Base Class
2. **تأكد من منطقية العلاقة** قبل التحويل
3. **تذكر قيود الوصول** بعد Up Casting

### ❌ تجنب:
1. **Down Casting نهائياً** في التصميم العادي
2. **الاعتماد على Casting** بشكل مفرط
3. **تجاهل قواعد الأمان** في الـ casting

## الخلاصة

### القاعدة الأساسية:
**"الكبير يدخل في الصغير، لكن الصغير لا يدخل في الكبير"**

### التطبيق العملي:
- **Up Casting:** Employee (كبير) → Person (صغير) ✅
- **Down Casting:** Person (صغير) → Employee (كبير) ❌

### نصيحة هامة:
- **Up Casting** آمن ومفيد للتصميم المرن
- **Down Casting** خطير ويجب تجنبه
- دائماً فكر في المنطق: هل المحتوى موجود فعلاً؟

</div>

<br><br><br><br><br><br><br><br><br>

<a id="english"></a>
[العربية ↗](#arabic)

# Up Casting vs Down Casting

## Review of Previous Lesson

In the previous lesson we learned:
- **Inheritance Types:** Single, Multi-Level, Hierarchical, Multiple, Hybrid
- **Safe Types:** Single, Multi-Level, Hierarchical
- **Dangerous Types:** Multiple, Hybrid (avoid completely)

## What is Casting?

**Casting** means converting from one Type to another Type.

### Examples from Basic Types:
- **int** to **double**
- **string** to **int** 
- **double** to **int**

This is what we learned in basic C++ courses.

## Casting in OOP

In **Object Oriented Programming** with **Inheritance**, there are two types of casting:

1. **Up Casting** ✅ (allowed and safe)
2. **Down Casting** ❌ (forbidden and dangerous)

## Understanding Class Relationships

### Our Basic Example:

```cpp
class clsPerson
{
public:
    string FullName = "Mohammed Abu-Hadhoud";
};

class clsEmployee : public clsPerson
{
public:
    string Title = "CEO";
};
```

### Relationship Analysis:
- **Person** = Base Class
- **Employee** = Derived Class  
- **Employee** contains everything in **Person** + more

### Visual Size Representation:

```
┌─────────────────┐
│    Employee     │ ← Large (contains everything)
│  ┌───────────┐  │
│  │  Person   │  │ ← Small (part of Employee)
│  │ FullName  │  │
│  └───────────┘  │
│     Title       │
└─────────────────┘
```

## Up Casting ✅

### Definition:
**Converting from Derived Class to Base Class**

### Principle:
- From **large** to **small** ✅
- From **Employee** to **Person** ✅

### Why allowed?
Because **Employee** contains **Person** inside it, so it's logical to extract the **Person** part.

### Practical Application :

```cpp
int main()
{
    // Create Employee object
    clsEmployee Employee1;
    cout << Employee1.FullName << endl;  // Mohammed Abu-Hadhoud
    
    // Up Casting ✅
    clsPerson* Person1 = &Employee1;  // Person pointer points to Employee
    cout << Person1->FullName << endl;  // Mohammed Abu-Hadhoud (same result)
    
    return 0;
}
```

### Up Casting Visual Diagram:

```
Employee object → Person pointer

┌─────────────────┐
│   Employee1     │
│  ┌───────────┐  │
│  │ FullName  │  │ ← Person1 accesses only this part
│  └───────────┘  │
│     Title       │ ← Cannot access this
└─────────────────┘

Person1 → Employee1.FullName ✓
Person1 → Employee1.Title ✗ (not available)
```

### Why can't we access Title?

Because **Person1** is a pointer of type **Person**, so it can only access members that exist in **Person Class**.

## Down Casting ❌

### Definition:
**Converting from Base Class to Derived Class**

### Principle:
- From **small** to **large** ❌
- From **Person** to **Employee** ❌

### Why forbidden?

```cpp
int main()
{
    // Create Person object
    clsPerson Person2;
    cout << Person2.FullName << endl;  // Mohammed Abu-Hadhoud
    
    // Down Casting ❌
    // clsEmployee* Employee2 = &Person2;  // error! Won't compile
    
    return 0;
}
```

### Why doesn't it work?

```
Person2 object:
┌───────────┐
│ FullName  │ ← contains only FullName
└───────────┘

Employee pointer wants:
┌─────────────────┐
│   Employee      │
│  ┌───────────┐  │
│  │ FullName  │  │ ← exists
│  └───────────┘  │  
│     Title       │ ← doesn't exist! Where would we get it?
└─────────────────┘
```

**Problem:** **Person** doesn't contain **Title**, so where would the **Employee pointer** get this variable?

## Visual Diagram

### Up Casting (allowed):

```
Person ←── Employee
  ↑    ✓    
Up Casting

Employee can be converted to Person through pointers
```

### Down Casting (forbidden):

```
Person ──── Employee
  ↓    ✗
Down Casting

Person cannot be converted to Employee through pointers
```

## Golden Rule

### ✅ Allowed:
**Base Class Pointer** can point to **Derived Class Object**

### ❌ Forbidden:
**Derived Class Pointer** cannot point to **Base Class Object**

## Why This Rule?

### Memory Logic:
- **Employee** = **Person** + additions
- When we convert **Employee** to **Person**: we ignore additions ✓
- When we convert **Person** to **Employee**: we need non-existent additions ✗

### Visual Analogy:
- **Employee** is like a large box containing a small box (**Person**)
- We can extract the small box from the large one ✓
- We cannot put the small box in place of the large one ✗

## Comparison Table

| Element | Up Casting | Down Casting |
|---------|------------|-------------|
| **Direction** | Derived → Base | Base → Derived |
| **Size** | Large → Small | Small → Large |
| **Safety** | ✅ Safe | ❌ Dangerous |
| **Permission** | ✅ Allowed | ❌ Forbidden |
| **Example** | Employee → Person | Person → Employee |

## Practical Application

### Using Up Casting:

```cpp
// Function that deals with Person
void PrintPersonInfo(clsPerson* person)
{
    cout << "Name: " << person->FullName << endl;
    // Cannot access Title here
}

int main()
{
    clsEmployee emp;
    clsPerson person;
    
    // Can pass Employee to function (Up Casting)
    PrintPersonInfo(&emp);     // ✓ works
    PrintPersonInfo(&person);  // ✓ works
    
    return 0;
}
```

## Best Practices

### ✅ Do:
1. **Use Up Casting** when you need to work with Base Class
2. **Ensure logical relationship** before casting
3. **Remember access limitations** after Up Casting

### ❌ Avoid:
1. **Down Casting completely** in normal design
2. **Over-reliance on Casting** excessively
3. **Ignoring safety rules** in casting

## Summary

### Basic Rule:
**"Large fits into small, but small doesn't fit into large"**

### Practical Application:
- **Up Casting:** Employee (large) → Person (small) ✅
- **Down Casting:** Person (small) → Employee (large) ❌

### Important Advice:
- **Up Casting** is safe and useful for flexible design
- **Down Casting** is dangerous and should be avoided
- Always think logically: does the content actually exist?

<br><br><br><br><br><br><br>
---
*Anas Chetoui - `anaschetoui`*
