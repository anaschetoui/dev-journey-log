<a id="arabic"></a>
[English ↙](#english)

<div dir="rtl" style="text-align: right;">

# الكائنات مع Parameterized Constructor والـ Array

## المفهوم الأساسي

**طريقة أنيقة لإنشاء مصفوفة كائنات بقيم محددة مسبقاً!**

بدلاً من الطرق المعقدة السابقة:
```cpp
// Dynamic Array
clsA * arr = new clsA[3];
arr[0] = clsA(10);  // تهيئة منفصلة
```

**نستخدم طريقة أبسط:**
```cpp
// Static Array مع Initialization List
clsA obj[] = { clsA(10), clsA(20), clsA(30) };
```

### المزايا:
- **بساطة:** خطوة واحدة للإنشاء والتهيئة
- **أمان:** لا حاجة لإدارة الذاكرة يدوياً
- **وضوح:** القيم واضحة في مكان واحد

## الـ Class المستخدمة

### ملاحظة مهمة: لا نحتاج Default Constructor!

</div>

```cpp
class clsA
{
public:
    int x;

    // Parameterized Constructor فقط
    clsA(int value)
    {
        x = value;
    }

    void Print()
    {
        cout << "The value of x=" << x << endl;
    }
};
```

<div dir="rtl" style="text-align: right;">

**لماذا لا نحتاج Default Constructor؟**
- لأننا ننشئ كل object بقيمة محددة مباشرة
- لا يوجد إنشاء "فارغ" ثم تهيئة منفصلة

## إنشاء Array بـ Initialization List

### الصيغة الأساسية:

</div>

```cpp
ClassName arrayName[] = { ClassName(param1), ClassName(param2), ClassName(param3) };
```

<div dir="rtl" style="text-align: right;">

### المثال العملي:

</div>

```cpp
// إنشاء 3 objects مع قيم مختلفة
clsA obj[] = { clsA(10), clsA(20), clsA(30) };
```

<div dir="rtl" style="text-align: right;">

### كيف تعمل العملية؟

</div>

```
obj[0] = clsA(10)  →  object بـ x=10
obj[1] = clsA(20)  →  object بـ x=20  
obj[2] = clsA(30)  →  object بـ x=30
```

<div dir="rtl" style="text-align: right;">

## الوصول للعناصر

### استخدام الفهرسة التقليدية:

</div>

```cpp
// الوصول لـ object معين
obj[0].Print();     // طباعة العنصر الأول
obj[1].x = 100;     // تعديل قيمة العنصر الثاني

// معالجة جميع العناصر
for (int i = 0; i < 3; i++) 
{
    obj[i].Print();
}
```

<div dir="rtl" style="text-align: right;">

## المثال الكامل العملي

</div>

```cpp
#include<iostream>
using namespace std;

class clsA
{
public:
    int x;

    // Parameterized Constructor
    clsA(int value)
    {
        x = value;
    }

    void Print()
    {
        cout << "The value of x=" << x << endl;
    }
};

int main() 
{
    // إنشاء 3 objects في المصفوفة مع استدعاءات constructor
    clsA obj[] = { clsA(10), clsA(20), clsA(30) };

    // استخدام method Print لكل عنصر من الثلاثة
    for (int i = 0; i < 3; i++) 
    {
        obj[i].Print();
    }

    return 0;
}
```

<div dir="rtl" style="text-align: right;">

## النتيجة المتوقعة:

</div>

```
The value of x=10
The value of x=20
The value of x=30
```

<div dir="rtl" style="text-align: right;">

## تحديد حجم المصفوفة تلقائياً

### الـ Compiler يحسب الحجم!

</div>

```cpp
// لا نحدد الحجم - الـ Compiler يحسبه من العناصر
clsA obj[] = { clsA(10), clsA(20), clsA(30) };  // الحجم = 3

// يمكننا إضافة المزيد ببساطة
clsA obj2[] = { clsA(1), clsA(2), clsA(3), clsA(4), clsA(5) };  // الحجم = 5
```

<div dir="rtl" style="text-align: right;">

### للحصول على الحجم برمجياً:

</div>

```cpp
int arraySize = sizeof(obj) / sizeof(obj[0]);
cout << "Array size: " << arraySize << endl;  // النتيجة: 3
```

<div dir="rtl" style="text-align: right;">

## مثال متقدم: مصفوفة الطلاب

</div>

```cpp
class Student
{
public:
    int id;
    string name;
    float grade;

    Student(int studentId, string studentName, float studentGrade)
    {
        id = studentId;
        name = studentName;
        grade = studentGrade;
    }

    void Print()
    {
        cout << "ID: " << id << ", Name: " << name 
             << ", Grade: " << grade << endl;
    }
};

int main()
{
    // إنشاء مصفوفة طلاب مع بيانات محددة
    Student students[] = {
        Student(101, "Ali", 85.5),
        Student(102, "Sara", 92.0),
        Student(103, "Ahmed", 78.5),
        Student(104, "Fatima", 95.0)
    };

    // حساب عدد الطلاب
    int numStudents = sizeof(students) / sizeof(students[0]);

    // طباعة بيانات جميع الطلاب
    for (int i = 0; i < numStudents; i++)
    {
        students[i].Print();
    }

    return 0;
}
```

<div dir="rtl" style="text-align: right;">

### النتيجة:

</div>

```
ID: 101, Name: Ali, Grade: 85.5
ID: 102, Name: Sara, Grade: 92
ID: 103, Name: Ahmed, Grade: 78.5
ID: 104, Name: Fatima, Grade: 95
```

<div dir="rtl" style="text-align: right;">

## مقارنة الطرق المختلفة

| الطريقة | المزايا | العيوب | الاستخدام المناسب |
|---------|---------|---------|------------------|
| **Initialization List** | بساطة، أمان، وضوح | حجم ثابت، قيم محددة مسبقاً | بيانات معروفة ومحددة |
| **Dynamic Array** | حجم متغير، تحكم في الذاكرة | تعقيد، إدارة يدوية | حجم محدد وقت التشغيل |
| **Vector** | مرونة، أمان، سهولة | استهلاك ذاكرة أكبر | تطبيقات عامة |

### مثال مقارن:

</div>

```cpp
// Initialization List - للبيانات المعروفة
Student students[] = {
    Student(101, "Ali", 85.5),
    Student(102, "Sara", 92.0)
};

// Dynamic Array - للحجم المتغير
int n;
cin >> n;
Student * dynStudents = new Student[n];
// تحتاج default constructor + تهيئة منفصلة

// Vector - للمرونة الكاملة
vector<Student> vecStudents;
vecStudents.push_back(Student(101, "Ali", 85.5));
```

<div dir="rtl" style="text-align: right;">

## متى تستخدم هذه الطريقة؟

### استخدم Initialization List عندما:
- **البيانات معروفة وقت الكتابة**
- **العدد ثابت ومحدود**
- **تريد بساطة وأمان**
- **لا تحتاج تعديل الحجم**

### لا تستخدمها عندما:
- **الحجم يعتمد على input المستخدم**
- **تحتاج إضافة/حذف عناصر**
- **البيانات تأتي من ملفات أو قواعد بيانات**

## الخلاصة

### النقاط الأساسية:
1. **`ClassName arr[] = { ClassName(param), ... }`** للإنشاء المباشر
2. **لا حاجة لـ Default Constructor** مع هذه الطريقة
3. **الـ Compiler يحدد الحجم تلقائياً** من عدد العناصر
4. **أبسط وأأمن** من Dynamic Arrays للبيانات المعروفة

</div>

<br><br><br><br><br><br><br><br><br>

<a id="english"></a>
[العربية ↗](#arabic)

# Objects with Parameterized Constructor and Array

## Basic Concept

**An elegant way to create an array of objects with predefined values!**

Instead of the complex previous methods:
```cpp
// Dynamic Array
clsA * arr = new clsA[3];
arr[0] = clsA(10);  // separate initialization
```

**We use a simpler method:**
```cpp
// Static Array with Initialization List
clsA obj[] = { clsA(10), clsA(20), clsA(30) };
```

### Advantages:
- **Simplicity:** one step for creation and initialization
- **Safety:** no need for manual memory management
- **Clarity:** values are clear in one place

## Class Used

### Important Note: No Default Constructor needed!

```cpp
class clsA
{
public:
    int x;

    // Parameterized Constructor only
    clsA(int value)
    {
        x = value;
    }

    void Print()
    {
        cout << "The value of x=" << x << endl;
    }
};
```

**Why don't we need Default Constructor?**
- Because we create each object with a specific value directly
- No "empty" creation then separate initialization

## Creating Array with Initialization List

### Basic Syntax:

```cpp
ClassName arrayName[] = { ClassName(param1), ClassName(param2), ClassName(param3) };
```

### Practical Example:

```cpp
// Creating 3 objects with different values
clsA obj[] = { clsA(10), clsA(20), clsA(30) };
```

### How the Process Works:

```
obj[0] = clsA(10)  →  object with x=10
obj[1] = clsA(20)  →  object with x=20  
obj[2] = clsA(30)  →  object with x=30
```

## Accessing Elements

### Using Traditional Indexing:

```cpp
// Access specific object
obj[0].Print();     // print first element
obj[1].x = 100;     // modify second element value

// Process all elements
for (int i = 0; i < 3; i++) 
{
    obj[i].Print();
}
```

## Complete Practical Example

```cpp
#include<iostream>
using namespace std;

class clsA
{
public:
    int x;

    // Parameterized Constructor
    clsA(int value)
    {
        x = value;
    }

    void Print()
    {
        cout << "The value of x=" << x << endl;
    }
};

int main() 
{
    // Initializing 3 array objects with function calls of
    // parameterized constructor as elements of that array
    clsA obj[] = { clsA(10), clsA(20), clsA(30) };

    // using print method for each of three elements
    for (int i = 0; i < 3; i++) 
    {
        obj[i].Print();
    }

    return 0;
}
```

## Expected Output:

```
The value of x=10
The value of x=20
The value of x=30
```

## Automatic Array Size Determination

### Compiler Calculates Size!

```cpp
// Don't specify size - compiler calculates from elements
clsA obj[] = { clsA(10), clsA(20), clsA(30) };  // size = 3

// Can add more simply
clsA obj2[] = { clsA(1), clsA(2), clsA(3), clsA(4), clsA(5) };  // size = 5
```

### To Get Size Programmatically:

```cpp
int arraySize = sizeof(obj) / sizeof(obj[0]);
cout << "Array size: " << arraySize << endl;  // Result: 3
```

## Advanced Example: Student Array

```cpp
class Student
{
public:
    int id;
    string name;
    float grade;

    Student(int studentId, string studentName, float studentGrade)
    {
        id = studentId;
        name = studentName;
        grade = studentGrade;
    }

    void Print()
    {
        cout << "ID: " << id << ", Name: " << name 
             << ", Grade: " << grade << endl;
    }
};

int main()
{
    // Create student array with specific data
    Student students[] = {
        Student(101, "Ali", 85.5),
        Student(102, "Sara", 92.0),
        Student(103, "Ahmed", 78.5),
        Student(104, "Fatima", 95.0)
    };

    // Calculate number of students
    int numStudents = sizeof(students) / sizeof(students[0]);

    // Print all student data
    for (int i = 0; i < numStudents; i++)
    {
        students[i].Print();
    }

    return 0;
}
```

### Output:

```
ID: 101, Name: Ali, Grade: 85.5
ID: 102, Name: Sara, Grade: 92
ID: 103, Name: Ahmed, Grade: 78.5
ID: 104, Name: Fatima, Grade: 95
```

## Comparison of Different Methods

| Method | Advantages | Disadvantages | Appropriate Use |
|--------|------------|---------------|-----------------|
| **Initialization List** | Simple, safe, clear | Fixed size, predefined values | Known and fixed data |
| **Dynamic Array** | Variable size, memory control | Complex, manual management | Runtime-determined size |
| **Vector** | Flexible, safe, easy | Higher memory usage | General applications |

### Comparison Example:

```cpp
// Initialization List - for known data
Student students[] = {
    Student(101, "Ali", 85.5),
    Student(102, "Sara", 92.0)
};

// Dynamic Array - for variable size
int n;
cin >> n;
Student * dynStudents = new Student[n];
// needs default constructor + separate initialization

// Vector - for full flexibility
vector<Student> vecStudents;
vecStudents.push_back(Student(101, "Ali", 85.5));
```

## When to Use This Method?

### Use Initialization List when:
- **Data is known at compile time**
- **Count is fixed and limited**
- **Want simplicity and safety**
- **Don't need to modify size**

### Don't use when:
- **Size depends on user input**
- **Need to add/remove elements**
- **Data comes from files or databases**

## Summary

### Key Points:
1. **`ClassName arr[] = { ClassName(param), ... }`** for direct creation
2. **No need for Default Constructor** with this method
3. **Compiler determines size automatically** from element count
4. **Simpler and safer** than Dynamic Arrays for known data
<br><br><br><br>
---

*Anas Chetoui - `anaschetoui`*
